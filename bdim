#!/usr/bin/env bash
# =============================================================================
# bdim â€” spec-kit tasks.md â†’ Beads â†’ GitHub Issues workflow bridge
# Version  : 3.0.0
# Requires : bash â‰¥ 3.2, jq, gh (GitHub CLI), bd (Beads CLI)
# =============================================================================
# SOURCE OF TRUTH MODEL
#   Phase 1 â€” spec-kit is canonical.  Run: /speckit.tasks â†’ generates tasks.md
#              Then: bdim create  (auto-reads .specify/specs/*/tasks.md)
#   Phase 2 â€” Beads are canonical.   Run: bdim convert / bdim sync
#   GitHub Issues are read-only projections of Beads.
#   GitHub edits do NOT flow back into Beads unless --force is used.
# =============================================================================

set -euo pipefail
IFS=$'\n\t'

VERSION="3.2.0"

# ---------------------------------------------------------------------------
# Colours (disabled when not a TTY)
# ---------------------------------------------------------------------------
if [[ -t 1 ]]; then
  RED='\033[0;31m'; YELLOW='\033[1;33m'; GREEN='\033[0;32m'
  BLUE='\033[0;34m'; CYAN='\033[0;36m'; BOLD='\033[1m'; RESET='\033[0m'
else
  RED=''; YELLOW=''; GREEN=''; BLUE=''; CYAN=''; BOLD=''; RESET=''
fi

# ---------------------------------------------------------------------------
# Global flags
# ---------------------------------------------------------------------------
DRY_RUN=false
VERBOSE=false
ALL_BEADS=false

# =============================================================================
# LOGGING
# =============================================================================

log_info()  { printf "${GREEN}[INFO]${RESET}  %s\n"  "$*"; }
log_warn()  { printf "${YELLOW}[WARN]${RESET}  %s\n"  "$*" >&2; }
log_error() { printf "${RED}[ERROR]${RESET} %s\n"  "$*" >&2; }
log_debug() { [[ "$VERBOSE" == true ]] && printf "${CYAN}[DEBUG]${RESET} %s\n" "$*" || true; }
log_dry()   { printf "${BLUE}[DRY]${RESET}   %s\n"  "$*"; }

die()       { log_error "$*"; exit 1; }
die_usage() { log_error "$*"; exit 2; }

# =============================================================================
# DEPENDENCY CHECKS
# =============================================================================

check_core_deps() {
  local missing=()
  command -v jq      &>/dev/null || missing+=("jq  (brew install jq)")
  # macOS ships shasum; Linux ships sha256sum
  { command -v sha256sum &>/dev/null || command -v shasum &>/dev/null; } \
    || missing+=("sha256sum / shasum")
  [[ ${#missing[@]} -eq 0 ]] || die "Missing dependencies: ${missing[*]}"
}

check_gh_dep() {
  command -v gh &>/dev/null || die "gh (GitHub CLI) required.  Install: brew install gh"
  if ! gh auth status &>/dev/null 2>&1; then
    die "gh is not authenticated.  Run: gh auth login"
  fi
}

check_bd_dep() {
  command -v bd &>/dev/null \
    || die "bd (Beads CLI) required.  Install: npm i -g @beads/bd  (or: brew install beads)"
}

check_specify_dep() {
  command -v specify &>/dev/null \
    || die "specify (spec-kit CLI) required.  Install: npm i -g @spec-kit/cli"
}

# Verify that a bd database has been initialised in (or above) the current
# directory.  Called after check_bd_dep so the error is targeted rather than
# a raw bd failure message.
check_bd_init() {
  if ! bd list --limit 1 --json &>/dev/null 2>&1; then
    die "No bd database found in this directory." \
        $'\n       ''Run '\''bd init'\'' in your project root, then try again.'
  fi
}

# Warn when .beads/issues.jsonl exists but the local bd database is empty.
# This almost always means the user forgot `bd import` after a `git pull`.
# Non-fatal â€” we warn and let the command continue so the user can decide.
check_bd_stale() {
  [[ -f ".beads/issues.jsonl" ]] || return 0  # no JSONL â†’ nothing to check

  local count
  count=$(bd list --all --limit 1 --json 2>/dev/null | jq 'length' 2>/dev/null || echo "0")

  if [[ "$count" == "0" ]]; then
    log_warn "bd database is empty but .beads/issues.jsonl exists."
    log_warn "Did you forget to run: bd import -i .beads/issues.jsonl"
    log_warn "Continuing â€” beads will be created fresh from this run."
  fi
}

# =============================================================================
# BD DATABASE EXPORT
# =============================================================================

# Export the full bd database to .beads/issues.jsonl so it can be committed
# to git and shared with the team.  Non-fatal â€” a warning is emitted on failure
# so the rest of the command still reports its summary correctly.
bd_export_jsonl() {
  local jsonl_path=".beads/issues.jsonl"

  if [[ "$DRY_RUN" == true ]]; then
    log_dry "Would export bead database â†’ $jsonl_path"
    return 0
  fi

  log_info "Exporting bead database â†’ $jsonl_path"

  if ! bd export -o "$jsonl_path" -q 2>&1; then
    log_warn "Could not export bead database to $jsonl_path"
    return 0  # non-fatal; sync state is still correct in bd
  fi

  log_info "  Done.  Commit $jsonl_path to share beads with your team."
  log_info "  Others can load it with: bd import -i $jsonl_path"
}

# =============================================================================
# UTILITIES
# =============================================================================

# Portable SHA-256 â†’ hex string of any stdin
_sha256() { command -v sha256sum &>/dev/null && sha256sum | awk '{print $1}' \
              || shasum -a 256 | awk '{print $1}'; }

sha256_of() { printf '%s' "$1" | _sha256; }

iso8601_now() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }

# spec-kit user story number â†’ Bead priority (US1=P1/high â€¦ none=P2/medium)
map_us_priority() {
  case "$1" in
    US1)          echo 1 ;;
    US2)          echo 2 ;;
    US[3-9]|US1[0-9]*) echo 3 ;;
    *)            echo 2 ;;   # setup / foundational / polish
  esac
}

# =============================================================================
# BEAD IDENTITY
# =============================================================================

# Stable external_ref derived deterministically from project + task ID.
# Format: "speckit-<project-id>-<task-id>"
# Scopes identity to the project, preventing cross-project collisions.
# Used as:
#   â€¢ the bd external_ref field (idempotency key for bd)
#   â€¢ the HTML comment anchor in GitHub issue bodies
compute_external_ref() {
  local project_id="$1"
  local task_id="$2"
  printf 'speckit-%s-%s' "$project_id" "$task_id"
}

# Content hash of key Bead fields (excludes sync-state metadata).
# A change in this hash means the Bead needs to be pushed to GitHub.
compute_content_hash() {
  local hash_json="$1"
  local canonical
  canonical=$(printf '%s' "$hash_json" | jq -c '{
    title, status, priority, issue_type, labels
  }')
  sha256_of "$canonical"
}

# =============================================================================
# BD HELPERS
# =============================================================================

# Get a single bead's full JSON from bd by its ID.
# Always returns a single JSON object (handles both object and array responses).
bd_get_bead_json() {
  local bd_id="$1"
  bd show "$bd_id" --json 2>/dev/null \
    | jq -c 'if type == "array" then .[0] else . end' 2>/dev/null
}

# Adapt bd show --json output to the internal format that format_gh_body expects.
# Maps bd field names â†’ the field names bdim uses internally.
bd_json_to_internal() {
  local bd_json="$1"
  jq -c '{
    title:                .title,
    description:          .description,
    acceptance_criteria:  (.acceptance_criteria // .acceptance),
    notes:                .notes,
    spec_id:              (.metadata.speckit_id // .external_ref),
    external_id:          .external_ref,
    due_at:               .due_at,
    assignee:             .assignee,
    estimated_minutes:    (.estimated_minutes // 0),
    issue_type:           (.issue_type // .type // "task"),
    priority:             (.priority // 2),
    status:               (.status // "open"),
    labels:               (.labels // []),
    metadata:             (.metadata // {})
  }' <<< "$bd_json"
}

# =============================================================================
# SPEC-KIT tasks.md â†’ BEADS  (Phase 1)
# =============================================================================

# ---------------------------------------------------------------------------
# spec-kit tasks.md line format:
#   - [ ] T001 Description with file path
#   - [ ] T005 [P] Implement auth middleware in src/middleware/auth.py
#   - [x] T012 [P] [US1] Create User model in src/models/user.py
#   - [ ] T014 [US1] Implement UserService in src/services/user_service.py
#
# Components:
#   - [ ] or - [x]  checkbox (open / closed)
#   T\d+            task ID  (T001, T002, â€¦)
#   [P]             optional â€” task is parallelisable
#   [US\d+]         optional â€” maps to user story (US1, US2, â€¦)
#   rest of line    description / title
#
# All other lines (headers, blank lines, comments, dependency sections) are
# silently skipped.
#
# Auto-discovery: specs/*/tasks.md relative to CWD.
# spec-kit places tasks.md at specs/<NNN-branch-name>/tasks.md in the repo root.
# Project ID per file: folder name with leading NNN- stripped and normalised.
# ---------------------------------------------------------------------------

# Derive a normalised project ID from a spec-kit feature folder name.
# Input:  "specs/001-my-feature"
# Output: "my-feature"
_project_id_from_folder() {
  local folder
  folder=$(basename "$1")
  # Strip leading NNN- numeric prefix (e.g. "001-")
  folder=$(printf '%s' "$folder" | sed 's/^[0-9]*-//')
  # Normalise: lowercase, collapse non-alnum runs to dash, trim edges
  printf '%s' "$folder" \
    | tr '[:upper:]' '[:lower:]' \
    | tr -cs 'a-z0-9' '-' \
    | sed 's/^-//;s/-$//'
}

# Pre-scan tasks.md to map US numbers â†’ epic titles from section headers.
# For each [US\d+] marker, the title comes from the nearest preceding ## header.
# Results stored in bash-3.2-safe named variables: us_title_1, us_title_2, â€¦
_collect_epic_titles() {
  local tasks_file="$1"
  local current_header=""
  local seen_us=" "   # space-padded string for whole-word membership tests

  while IFS= read -r line; do

    # Track most-recent ## section header
    if [[ "$line" =~ ^##[[:space:]]+(.+)$ ]]; then
      current_header="${BASH_REMATCH[1]}"
      current_header=$(printf '%s' "$current_header" | sed 's/[[:space:]]*$//')
      continue
    fi

    # Check for a [US\d+] marker anywhere on the line
    if [[ "$line" =~ \[US([0-9]+)\] ]]; then
      local us_num="${BASH_REMATCH[1]}"
      # Only record the first occurrence per US number
      [[ "$seen_us" == *" ${us_num} "* ]] && continue
      seen_us+="${us_num} "

      # Extract a clean title from the current section header.
      # Matches: "... User Story N - Some Title (optional suffix) ðŸŽ¯ emoji"
      local epic_title=""
      if [[ -n "$current_header" && \
            "$current_header" =~ User[[:space:]]+Story[[:space:]]+${us_num}[^-]*-[[:space:]]*(.+) ]]; then
        epic_title="${BASH_REMATCH[1]}"
        # Strip trailing "(â€¦)" parentheticals (e.g. "(Priority: P1)") and trailing spaces
        epic_title=$(printf '%s' "$epic_title" | sed 's/[[:space:]]*(.*$//' | sed 's/[[:space:]]*$//')
      fi

      if [[ -n "$epic_title" ]]; then
        epic_title="User Story ${us_num}: ${epic_title}"
      else
        epic_title="User Story ${us_num}"
      fi

      printf -v "us_title_${us_num}" '%s' "$epic_title"
      log_debug "Epic title for US${us_num}: ${epic_title}"
    fi

  done < "$tasks_file"
}

# Return value global for _ensure_epic_bead.
_EPIC_BEAD_ACTION=""  # "created" | "updated" | "skipped" | "failed"

# Create (or locate/update) the Beads epic for a user story tag.
# Stores results in bash-3.2-safe named globals:
#   us_epic_id_N  â€” bd bead ID (empty in dry-run; placeholder used internally)
#   us_epic_ref_N â€” external_ref string (always set)
# Sets _EPIC_BEAD_ACTION to: "created" | "updated" | "skipped" | "failed"
_ensure_epic_bead() {
  local project_id="$1"
  local user_story_tag="$2"    # e.g. "US1"
  local epic_title="$3"        # e.g. "User Story 1: Import spec-kit tasks"
  local all_beads_json="$4"    # pre-fetched speckit beads JSON (may be "" in dry-run)

  local us_num="${user_story_tag#US}"
  local epic_external_ref="speckit-${project_id}-${user_story_tag}"
  local epic_priority
  epic_priority=$(map_us_priority "$user_story_tag")

  # Compute a stable content hash for this epic
  local epic_hash_json epic_content_hash
  epic_hash_json=$(jq -cn \
    --arg  title      "$epic_title" \
    --arg  issue_type "epic" \
    --argjson priority "$epic_priority" \
    --arg  us         "$user_story_tag" \
    '{title, issue_type, priority, user_story: $us}')
  epic_content_hash=$(compute_content_hash "$epic_hash_json")

  # Always register the external_ref so child tasks can reference it
  printf -v "us_epic_ref_${us_num}" '%s' "$epic_external_ref"
  _EPIC_BEAD_ACTION="failed"

  # ---- Dry-run path --------------------------------------------------------
  if [[ "$DRY_RUN" == true ]]; then
    log_dry "Would create epic: [${user_story_tag} / P${epic_priority}] ${epic_title}"
    printf -v "us_epic_id_${us_num}" '%s' "dry-run-${user_story_tag}"
    _EPIC_BEAD_ACTION="created"
    return
  fi

  # ---- Idempotency: check for existing epic bead ---------------------------
  local epic_bd_id=""
  if [[ -n "$all_beads_json" ]]; then
    epic_bd_id=$(printf '%s' "$all_beads_json" \
      | jq -r --arg ref "$epic_external_ref" \
        '.[]? | select(.external_ref == $ref) | .id' | head -1)
  fi

  if [[ -n "$epic_bd_id" ]]; then
    # Epic exists â€” skip if unchanged, otherwise update title/priority
    local existing_epic_json existing_epic_hash
    existing_epic_json=$(bd_get_bead_json "$epic_bd_id")
    existing_epic_hash=$(printf '%s' "$existing_epic_json" \
      | jq -r '.metadata.content_hash // ""' 2>/dev/null || true)

    if [[ "$existing_epic_hash" == "$epic_content_hash" ]]; then
      log_debug "Epic for ${user_story_tag} unchanged â€” skipped ($epic_bd_id)"
      printf -v "us_epic_id_${us_num}" '%s' "$epic_bd_id"
      _EPIC_BEAD_ACTION="skipped"
      return
    fi

    log_info "Updating epic: ${user_story_tag} â€” ${epic_title}"
    bd update "$epic_bd_id" --title "$epic_title" -t epic \
      -p "$epic_priority" --set-labels "speckit,${user_story_tag},epic" -q 2>/dev/null \
      || log_warn "Could not update epic bead $epic_bd_id"

    local updated_meta
    updated_meta=$(printf '%s' "$existing_epic_json" | jq -c \
      --arg ch "$epic_content_hash" \
      '(.metadata // {}) + {content_hash: $ch}')
    bd update "$epic_bd_id" --metadata "$updated_meta" -q 2>/dev/null \
      || log_warn "Could not update metadata on epic $epic_bd_id"

    printf -v "us_epic_id_${us_num}" '%s' "$epic_bd_id"
    log_info "  Updated epic: $epic_bd_id"
    _EPIC_BEAD_ACTION="updated"
    return
  fi

  # ---- Create new epic bead ------------------------------------------------
  log_info "Creating epic: ${user_story_tag} â€” ${epic_title}"

  local new_epic_id
  if ! new_epic_id=$(bd create "$epic_title" \
      --external-ref "$epic_external_ref" \
      -t epic \
      -l "speckit,${user_story_tag},epic" \
      -p "$epic_priority" \
      --silent 2>/dev/null); then
    log_error "Failed to create epic bead for ${user_story_tag}"
    return
  fi
  new_epic_id=$(printf '%s' "$new_epic_id" | tr -d '[:space:]')

  local epic_meta
  epic_meta=$(jq -cn \
    --arg us   "$user_story_tag" \
    --arg ref  "$epic_external_ref" \
    --arg ch   "$epic_content_hash" \
    '{
      source_system: "speckit",
      is_epic:       true,
      user_story:    $us,
      task_id:       $ref,
      content_hash:  $ch
    }')
  bd update "$new_epic_id" --metadata "$epic_meta" -q 2>/dev/null \
    || log_warn "Could not set metadata on epic $new_epic_id"

  printf -v "us_epic_id_${us_num}" '%s' "$new_epic_id"
  log_info "  Created epic: $new_epic_id"
  _EPIC_BEAD_ACTION="created"
}

_process_tasks_file() {
  local tasks_file="$1"
  local project_id="$2"

  local created=0 updated=0 skipped=0 failed=0 task_count=0 epics_created=0

  log_info "tasks.md     : $tasks_file"
  log_info "Project ID   : $project_id"

  # Pre-fetch the full speckit bead list once for O(1) idempotency lookups.
  local _all_beads_json=""
  [[ "$DRY_RUN" != true ]] && \
    _all_beads_json=$(bd list --all --limit 0 -l speckit --json 2>/dev/null || true)

  # Pre-scan to map US numbers â†’ epic titles from section headers
  _collect_epic_titles "$tasks_file"

  # Track which US numbers have had their epic bead created/located
  local us_seen_epic=" "

  while IFS= read -r line; do

    # Match checklist lines only: - [ ] T001 ... or - [x] T001 ...
    [[ "$line" =~ ^[[:space:]]*-[[:space:]]\[([[:space:]x])\][[:space:]]+(T[0-9]+)(.*) ]] \
      || continue

    local checked="${BASH_REMATCH[1]}"
    local task_id="${BASH_REMATCH[2]}"
    local rest="${BASH_REMATCH[3]}"

    # Markers [P] and [US\d+] always appear immediately after the task ID,
    # before the description.  Parse positionally from the left so that [P]
    # inside description text (e.g. "(ID, [P], [US#], status)") is ignored.

    # Trim leading whitespace first
    rest=$(printf '%s' "$rest" | sed 's/^[[:space:]]*//')

    # Extract optional [P] parallelism marker (only if at start of rest)
    local parallel=false
    if printf '%s' "$rest" | grep -qE '^\[P\]([[:space:]]|$)'; then
      parallel=true
      rest=$(printf '%s' "$rest" | sed 's/^\[P\][[:space:]]*//')
    fi

    # Extract optional [US\d+] user-story marker (only if at start of rest)
    local user_story=""
    if printf '%s' "$rest" | grep -qE '^\[US[0-9]+\]([[:space:]]|$)'; then
      user_story=$(printf '%s' "$rest" | grep -oE '^\[US[0-9]+\]' | tr -d '[]' || true)
      rest=$(printf '%s' "$rest" | sed 's/^\[US[0-9]*\][[:space:]]*//')
    fi

    # Trim whitespace from description
    local title
    title=$(printf '%s' "$rest" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    if [[ -z "$title" ]]; then
      log_warn "Skipping $task_id: empty description"
      failed=$(( failed + 1 )); continue
    fi

    task_count=$(( task_count + 1 ))

    # ---- Ensure epic bead exists for this user story (first encounter) -----
    local us_num=""
    if [[ -n "$user_story" ]]; then
      us_num="${user_story#US}"
      if [[ "$us_seen_epic" != *" ${us_num} "* ]]; then
        local epic_title_val
        eval "epic_title_val=\${us_title_${us_num}:-User Story ${us_num}}"
        _ensure_epic_bead "$project_id" "$user_story" "$epic_title_val" "$_all_beads_json"
        us_seen_epic+="${us_num} "
        case "$_EPIC_BEAD_ACTION" in
          created|updated) epics_created=$(( epics_created + 1 )) ;;
        esac
      fi
    fi

    # ---- Map fields --------------------------------------------------------
    local bead_status bead_priority
    [[ "$checked" == "x" ]] && bead_status="closed" || bead_status="open"
    bead_priority=$(map_us_priority "$user_story")

    # Labels: speckit (always) + user story (if any) + parallel (if flagged)
    local all_labels="speckit"
    [[ -n "$user_story" ]] && all_labels+=",$user_story"
    [[ "$parallel" == true ]] && all_labels+=",parallel"

    local labels_json
    labels_json=$(printf '%s' "$all_labels" | tr ',' '\n' \
      | jq -Rc '[inputs | select(length > 0)]')

    # ---- Content hash ------------------------------------------------------
    local external_ref content_hash hash_json
    external_ref=$(compute_external_ref "$project_id" "$task_id")
    hash_json=$(jq -cn \
      --arg  title      "$title" \
      --arg  status     "$bead_status" \
      --argjson priority "$bead_priority" \
      --arg  issue_type "task" \
      --argjson labels  "$labels_json" \
      '{title, status, priority, issue_type, labels}')
    content_hash=$(compute_content_hash "$hash_json")

    log_debug "Processing $task_id â†’ external_ref: $external_ref"

    # ---- Idempotency: check for existing bead in bd ------------------------
    local bd_id=""
    [[ "$DRY_RUN" != true ]] && bd_id=$(printf '%s' "$_all_beads_json" \
      | jq -r --arg ref "$external_ref" '.[]? | select(.external_ref == $ref) | .id' \
      | head -1)

    # ---- Base metadata -----------------------------------------------------
    local parallel_bool="false"
    [[ "$parallel" == true ]] && parallel_bool="true"

    local parent_external_ref=""
    if [[ -n "$user_story" && -n "$us_num" ]]; then
      eval "parent_external_ref=\${us_epic_ref_${us_num}:-}"
    fi

    local base_meta_json
    base_meta_json=$(jq -cn \
      --arg  ch    "$content_hash" \
      --arg  tid   "$task_id" \
      --arg  us    "$user_story" \
      --arg  pref  "$parent_external_ref" \
      --argjson p  "$parallel_bool" \
      '{
        source_system:       "speckit",
        speckit_id:          $tid,
        task_id:             $tid,
        content_hash:        $ch,
        user_story:          (if $us   != "" then $us   else null end),
        parent_external_ref: (if $pref != "" then $pref else null end),
        parallel:            $p
      } | with_entries(select(.value != null))')

    # ========================================================================
    # CREATE â€” no existing bead found
    # ========================================================================
    if [[ -z "$bd_id" ]]; then

      if [[ "$DRY_RUN" == true ]]; then
        local us_tag=""
        [[ -n "$user_story" ]] && us_tag=" [$user_story]"
        [[ "$parallel" == true ]] && us_tag+=" [P]"
        log_dry "Would create: [$task_id / P${bead_priority}${us_tag}] $title"
        created=$(( created + 1 )); continue
      fi

      log_info "Creating bead: $task_id â€” $title"

      local create_args=("$title")
      create_args+=(--external-ref "$external_ref")
      create_args+=(-l "$all_labels")
      create_args+=(-p "$bead_priority")
      create_args+=(-t "task")
      create_args+=(--silent)

      local new_bd_id
      if ! new_bd_id=$(bd create "${create_args[@]}" 2>/dev/null); then
        log_error "Failed to create bead for $task_id"
        failed=$(( failed + 1 )); continue
      fi
      new_bd_id=$(printf '%s' "$new_bd_id" | tr -d '[:space:]')

      # Set closed status if task was already checked off
      if [[ "$bead_status" == "closed" ]]; then
        bd update "$new_bd_id" -s "closed" -q 2>/dev/null \
          || log_warn "Could not set status 'closed' on $new_bd_id"
      fi

      bd update "$new_bd_id" --metadata "$base_meta_json" -q 2>/dev/null \
        || log_warn "Could not set metadata on $new_bd_id"

      log_info "  Created: $new_bd_id"
      created=$(( created + 1 ))

    else
    # ========================================================================
    # UPDATE or SKIP â€” bead already exists
    # ========================================================================

      local existing_json existing_hash
      existing_json=$(bd_get_bead_json "$bd_id")
      existing_hash=$(printf '%s' "$existing_json" \
        | jq -r '.metadata.content_hash // ""' 2>/dev/null || true)

      if [[ "$existing_hash" == "$content_hash" ]]; then
        log_debug "Bead $external_ref unchanged â€” skipped"
        skipped=$(( skipped + 1 )); continue
      fi

      log_info "Updating bead: $bd_id  ($external_ref)"

      local update_args=("$bd_id")
      update_args+=(--title "$title")
      update_args+=(-p "$bead_priority")
      update_args+=(-t "task")
      update_args+=(-s "$bead_status")
      update_args+=(--set-labels "$all_labels")
      update_args+=(-q)

      if ! bd update "${update_args[@]}" 2>/dev/null; then
        log_error "Failed to update bead $bd_id"
        failed=$(( failed + 1 )); continue
      fi

      # Preserve existing GitHub sync fields when rebuilding metadata
      local gh_num gh_url gh_synced gh_synced_hash
      gh_num=$(printf '%s'         "$existing_json" | jq -r '.metadata.github_issue_number      // ""')
      gh_url=$(printf '%s'         "$existing_json" | jq -r '.metadata.github_issue_url         // ""')
      gh_synced=$(printf '%s'      "$existing_json" | jq -r '.metadata.github_issue_synced_at   // ""')
      gh_synced_hash=$(printf '%s' "$existing_json" | jq -r '.metadata.github_issue_synced_hash // ""')

      local full_meta_json
      full_meta_json=$(printf '%s' "$base_meta_json" | jq -c \
        --arg ghu  "$gh_url" \
        --arg ghs  "$gh_synced" \
        --arg ghsh "$gh_synced_hash" \
        '. +
        (if $ghu  != "" then {github_issue_url:         $ghu}  else {} end) +
        (if $ghs  != "" then {github_issue_synced_at:   $ghs}  else {} end) +
        (if $ghsh != "" then {github_issue_synced_hash: $ghsh} else {} end)')

      if [[ -n "$gh_num" && "$gh_num" != "null" ]]; then
        full_meta_json=$(printf '%s' "$full_meta_json" \
          | jq -c --argjson n "$gh_num" '. + {github_issue_number: $n}')
      fi

      bd update "$bd_id" --metadata "$full_meta_json" -q 2>/dev/null \
        || log_warn "Could not update metadata on $bd_id"

      log_info "  Updated: $bd_id"
      updated=$(( updated + 1 ))
    fi

  done < "$tasks_file"

  printf '\n'
  log_info "  Tasks parsed : $task_count  |  created: $created, updated: $updated, skipped: $skipped, failed: $failed"
  [[ "$epics_created" -gt 0 ]] && log_info "  Epics created: $epics_created"

  # Return counters via globals so caller can accumulate across files
  _S2B_CREATED=$(( _S2B_CREATED + created ))
  _S2B_UPDATED=$(( _S2B_UPDATED + updated ))
  _S2B_FAILED=$((  _S2B_FAILED  + failed  ))
  _S2B_EPICS=$((   _S2B_EPICS   + epics_created ))
}

# Global accumulators for _process_tasks_file
_S2B_CREATED=0
_S2B_UPDATED=0
_S2B_FAILED=0
_S2B_EPICS=0

cmd_create() {
  local project_id_flag=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project|-p)   project_id_flag="$2"; shift 2 ;;
      --dry-run)      DRY_RUN=true;         shift ;;
      --verbose|-v)   VERBOSE=true;         shift ;;
      -*)             die "Unknown option: $1" ;;
      *)              die_usage "create takes no positional arguments â€” tasks.md files are auto-discovered under specs/" ;;
    esac
  done

  [[ "$DRY_RUN" != true ]] && check_bd_dep
  [[ "$DRY_RUN" != true ]] && check_bd_init
  [[ "$DRY_RUN" != true ]] && check_bd_stale

  # Discover all tasks.md files under specs/*/  (spec-kit default layout)
  local tasks_files=()
  while IFS= read -r f; do
    [[ -f "$f" ]] && tasks_files+=("$f")
  done < <(find specs -mindepth 2 -maxdepth 2 -name tasks.md 2>/dev/null | sort)

  if [[ ${#tasks_files[@]} -eq 0 ]]; then
    die "No tasks.md files found under specs/." \
        $'\n       ''Run /speckit.tasks to generate a tasks.md first.'
  fi

  # --project only makes sense when there is exactly one file
  if [[ -n "$project_id_flag" && ${#tasks_files[@]} -gt 1 ]]; then
    die "--project can only be used when there is a single tasks.md (found ${#tasks_files[@]})"
  fi

  log_info "Found ${#tasks_files[@]} tasks.md file(s)"
  [[ "$DRY_RUN" == true ]] && log_warn "Dry-run mode â€” no beads will be created or updated"

  _S2B_CREATED=0; _S2B_UPDATED=0; _S2B_FAILED=0; _S2B_EPICS=0

  local f project_id
  for f in "${tasks_files[@]}"; do
    if [[ -n "$project_id_flag" ]]; then
      project_id="$project_id_flag"
    else
      project_id=$(_project_id_from_folder "$(dirname "$f")")
    fi
    _process_tasks_file "$f" "$project_id"
  done

  printf '\n'
  log_info "create complete â€” epics: $_S2B_EPICS, created: $_S2B_CREATED, updated: $_S2B_UPDATED, failed: $_S2B_FAILED"
  [[ "$DRY_RUN" == true ]] && log_warn "Dry-run â€” no beads were created or updated."

  [[ $(( _S2B_CREATED + _S2B_UPDATED )) -gt 0 ]] && bd_export_jsonl

  [[ $_S2B_FAILED -eq 0 ]] || return 1
}

# =============================================================================
# GITHUB BODY FORMATTER
# =============================================================================

# Produces a clean GitHub Markdown issue body.
# The hidden HTML comment <!-- bdim:external_id:... --> is the idempotency
# anchor used by find_gh_issue_by_external_id().
# Expects the internal bead format produced by bd_json_to_internal().
format_gh_body() {
  local bead_json="$1"

  local task_id external_id title priority
  task_id=$(printf '%s'    "$bead_json" | jq -r '.metadata.task_id  // ""')
  external_id=$(printf '%s' "$bead_json" | jq -r '.external_id       // ""')
  title=$(printf '%s'      "$bead_json" | jq -r '.title              // ""')
  priority=$(printf '%s'   "$bead_json" | jq -r '.priority           // 2')

  local body=""

  # spec-kit task bead â€” task_id is the primary identifier
  if [[ -n "$task_id" ]]; then
    local user_story parallel
    user_story=$(printf '%s' "$bead_json" | jq -r '.metadata.user_story // ""')
    parallel=$(printf '%s'   "$bead_json" | jq -r '.metadata.parallel   // false')

    local summary="\`${task_id}\`"
    [[ -n "$user_story"      ]] && summary+=" Â· User Story: ${user_story}"
    [[ "$parallel" == "true" ]] && summary+=" Â· Parallel: yes"

    body+="## Task\n\n${summary}\n\n"
    body+="---\n\n"
    body+="| Field | Value |\n"
    body+="| --- | --- |\n"
    body+="| Task ID | \`${task_id}\` |\n"
    [[ -n "$user_story"      ]] && body+="| User Story | \`${user_story}\` |\n"
    body+="| Priority | P${priority} |\n"
    [[ "$parallel" == "true" ]] && body+="| Parallel | yes |\n"

  else
    # Legacy / non-task bead
    local description acc_criteria notes spec_id due_at assignee estimated_minutes milestone
    description=$(printf '%s'       "$bead_json" | jq -r '.description          // ""')
    acc_criteria=$(printf '%s'      "$bead_json" | jq -r '.acceptance_criteria  // ""')
    notes=$(printf '%s'             "$bead_json" | jq -r '.notes                // ""')
    spec_id=$(printf '%s'           "$bead_json" | jq -r '.spec_id              // ""')
    due_at=$(printf '%s'            "$bead_json" | jq -r '.due_at               // ""')
    assignee=$(printf '%s'          "$bead_json" | jq -r '.assignee             // ""')
    estimated_minutes=$(printf '%s' "$bead_json" | jq -r '.estimated_minutes    // 0')
    milestone=$(printf '%s'         "$bead_json" | jq -r '.metadata.milestone   // ""')

    [[ -n "$description" ]]  && body+="## Description\n\n${description}\n\n"
    [[ -n "$acc_criteria" ]] && body+="## Acceptance Criteria\n\n${acc_criteria}\n\n"
    [[ -n "$notes" ]]        && body+="## Notes\n\n${notes}\n\n"

    body+="---\n\n"
    body+="| Field | Value |\n"
    body+="| --- | --- |\n"
    [[ -n "$spec_id" ]]  && body+="| Speckit ID | \`${spec_id}\` |\n"
    body+="| Priority | P${priority} |\n"
    [[ -n "$due_at"    ]] && body+="| Due date | \`${due_at}\` |\n"
    [[ -n "$milestone" ]] && body+="| Milestone | ${milestone} |\n"
    [[ -n "$assignee"  ]] && body+="| Assignee | @${assignee} |\n"

    if [[ "$estimated_minutes" -gt 0 ]]; then
      local h=$(( estimated_minutes / 60 ))
      local m=$(( estimated_minutes % 60 ))
      local est=""
      [[ $h -gt 0 ]] && est+="${h}h"
      [[ $m -gt 0 ]] && est+=" ${m}m"
      body+="| Estimate | \`${est}\` |\n"
    fi
  fi

  body+="\n_Managed by [bdim](https://github.com/steveyegge/beads). "
  body+="Edit the Bead, not this issue._\n\n"
  # Idempotency anchor â€” DO NOT REMOVE
  body+="<!-- bdim:external_id:${external_id} -->"

  printf '%b' "$body"
}

# Produces a GitHub Markdown issue body for an epic bead.
# children_json: JSON array of {task_id, title, github_issue_number} objects.
# On first sync, github_issue_number may be null â€” task-list entries fall back
# to plain text.  A subsequent bdim sync fills in the real #N links once
# child issues exist.
format_epic_gh_body() {
  local bead_json="$1"
  local children_json="$2"

  local external_id title priority user_story
  external_id=$(printf '%s' "$bead_json" | jq -r '.external_id          // ""')
  title=$(printf '%s'       "$bead_json" | jq -r '.title                // ""')
  priority=$(printf '%s'    "$bead_json" | jq -r '.priority             // 2')
  user_story=$(printf '%s'  "$bead_json" | jq -r '.metadata.user_story  // ""')

  local body=""
  body+="## Epic: ${title}\n\n"
  body+="| Field | Value |\n"
  body+="| --- | --- |\n"
  body+="| Type | epic |\n"
  [[ -n "$user_story" ]] && body+="| User Story | \`${user_story}\` |\n"
  body+="| Priority | P${priority} |\n"

  # Children task list
  local children_count
  children_count=$(printf '%s' "$children_json" | jq 'length' 2>/dev/null || echo 0)

  if [[ "$children_count" -gt 0 ]]; then
    body+="\n## Children\n\n"
    while IFS= read -r child; do
      local child_task_id child_title child_gh_num
      child_task_id=$(printf '%s' "$child" | jq -r '.task_id              // ""')
      child_title=$(printf '%s'   "$child" | jq -r '.title                // ""')
      child_gh_num=$(printf '%s'  "$child" | jq -r '.github_issue_number  // ""')

      local task_label="${child_task_id}: ${child_title}"
      if [[ -n "$child_gh_num" && "$child_gh_num" != "null" ]]; then
        body+="- [ ] #${child_gh_num} ${task_label}\n"
      else
        body+="- [ ] ${task_label}\n"
      fi
    done < <(printf '%s' "$children_json" | jq -c '.[]' 2>/dev/null)
  fi

  body+="\n_Managed by [bdim](https://github.com/steveyegge/beads). "
  body+="Edit the Bead, not this issue._\n\n"
  # Idempotency anchor â€” DO NOT REMOVE
  body+="<!-- bdim:external_id:${external_id} -->"

  printf '%b' "$body"
}

# =============================================================================
# GITHUB HELPERS
# =============================================================================

# Search GitHub for an issue whose body contains the idempotency anchor.
# Returns the issue number, or empty string if not found.
find_gh_issue_by_external_id() {
  local repo="$1"
  local external_id="$2"

  log_debug "Searching GitHub for external_id: $external_id"

  local query="repo:${repo} in:body bdim:external_id:${external_id}"
  gh api "search/issues" \
    --method GET \
    -f q="$query" \
    --jq '.items[0].number // empty' 2>/dev/null || true
}

# Ensure a label exists in the repo, creating it with a random colour if not.
ensure_label_exists() {
  local repo="$1"
  local label="$2"
  [[ -z "$label" ]] && return 0

  if ! gh api "repos/${repo}/labels" --jq ".[].name" 2>/dev/null \
        | grep -qxF "$label"; then
    log_debug "Creating label: $label"
    local colour
    colour=$(printf '%06X' $(( RANDOM % 16777215 )))
    gh api "repos/${repo}/labels" \
      --method POST \
      -f name="$label" \
      -f color="$colour" \
      --silent &>/dev/null || log_warn "Could not create label: $label"
  fi
}

# Resolve a milestone title to its numeric ID (or empty string).
get_milestone_id() {
  local repo="$1"
  local title="$2"
  [[ -z "$title" ]] && return 0
  gh api "repos/${repo}/milestones" \
    --jq ".[] | select(.title == \"${title}\") | .number" \
    2>/dev/null | head -1 || true
}

# Build a JSON array of labels from a newline-separated list.
labels_to_json_array() {
  local labels_raw="$1"
  printf '%s' "$labels_raw" | jq -Rc '[inputs | select(length > 0)]'
}

# =============================================================================
# BEADS â†’ GITHUB  (Phase 2)
# =============================================================================

# ---------------------------------------------------------------------------
# Field mapping contract â€” Bead â†’ GitHub Issue
#
# Bead field               GitHub field        Notes
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# title                  â†’ title              direct
# description            â†’ body (section)     composed markdown
# acceptance_criteria    â†’ body (section)     composed markdown
# notes                  â†’ body (section)     composed markdown
# spec_id (metadata)     â†’ body (table row)   reference only
# external_ref           â†’ body (HTML comment) idempotency anchor
# labels[]               â†’ labels[]           created if missing
# assignee               â†’ assignees[0]       single assignee
# metadata.milestone     â†’ milestone.title    resolved to milestone number
# status == "closed"     â†’ state = "closed"   open otherwise
# metadata.github_issue_number â† stored back via bd update --metadata
# metadata.github_issue_url    â† stored back via bd update --metadata
# metadata.github_issue_synced_at   â† timestamp of last successful sync
# metadata.github_issue_synced_hash â† content_hash at last sync
# ---------------------------------------------------------------------------

# Global used by _sync_one_bead to avoid stdout pollution in subshells.
_BEAD_SYNC_RESULT=""

_sync_one_bead() {
  local repo="$1"
  local bd_raw_json="$2"   # raw JSON from bd show --json (single object)
  local bd_id="$3"
  local force_update="$4"
  local children_list_json="${5:-}"  # JSON array of children for epic issues
  # Sets _BEAD_SYNC_RESULT to: "created" | "updated" | "skipped" | "failed"

  _BEAD_SYNC_RESULT="failed"

  # Adapt bd JSON to the internal format that format_gh_body expects
  local bead_json
  bead_json=$(bd_json_to_internal "$bd_raw_json")

  local external_id title
  external_id=$(printf '%s' "$bead_json" | jq -r '.external_id // ""')
  title=$(printf '%s'       "$bead_json" | jq -r '.title       // ""')

  if [[ -z "$external_id" || -z "$title" ]]; then
    log_warn "Bead $bd_id missing external_ref or title â€” skipped"
    return
  fi

  log_debug "Syncing bead: $bd_id  ($external_id)"

  # ---- Resolve existing GitHub issue number (skipped in dry-run) -----------
  local gh_number=""
  local stored_number
  stored_number=$(printf '%s' "$bd_raw_json" | jq -r '.metadata.github_issue_number // empty')

  if [[ -n "$stored_number" && "$stored_number" != "null" ]]; then
    gh_number="$stored_number"
    log_debug "  Stored issue number: #$gh_number"
  elif [[ "$DRY_RUN" != true ]]; then
    gh_number=$(find_gh_issue_by_external_id "$repo" "$external_id")
    [[ -n "$gh_number" ]] && log_debug "  Found via search: #$gh_number"
  fi

  # ---- Prepare GitHub payload ----------------------------------------------
  local body
  local is_epic
  is_epic=$(printf '%s' "$bd_raw_json" | jq -r '.metadata.is_epic // false')
  if [[ "$is_epic" == "true" ]]; then
    body=$(format_epic_gh_body "$bead_json" "${children_list_json:-[]}")
  else
    body=$(format_gh_body "$bead_json")
  fi

  local labels_raw
  labels_raw=$(printf '%s' "$bead_json" | jq -r '.labels // [] | .[]' 2>/dev/null)

  local assignee
  assignee=$(printf '%s' "$bead_json" | jq -r '.assignee // ""')

  local bead_status gh_state
  bead_status=$(printf '%s' "$bead_json" | jq -r '.status // "open"')
  [[ "$bead_status" == "closed" ]] && gh_state="closed" || gh_state="open"

  # ---- Ensure labels exist (skip in dry-run) -------------------------------
  if [[ "$DRY_RUN" != true ]]; then
    while IFS= read -r lbl; do
      [[ -n "$lbl" ]] && ensure_label_exists "$repo" "$lbl"
    done <<< "$labels_raw"
  fi

  # ---- Milestone (skip in dry-run) -----------------------------------------
  local milestone_title milestone_id=""
  milestone_title=$(printf '%s' "$bead_json" | jq -r '.metadata.milestone // ""')
  if [[ -n "$milestone_title" && "$DRY_RUN" != true ]]; then
    milestone_id=$(get_milestone_id "$repo" "$milestone_title")
  fi

  local now
  now=$(iso8601_now)
  local current_hash
  current_hash=$(printf '%s' "$bd_raw_json" | jq -r '.metadata.content_hash // ""')

  # ---- CREATE new issue ----------------------------------------------------
  if [[ -z "$gh_number" ]]; then
    log_info "  Creating issue: $title"

    if [[ "$DRY_RUN" == true ]]; then
      local dry_labels
      dry_labels=$(printf '%s' "$labels_raw" | tr '\n' ' ')
      log_dry "  Would create: $title  [labels: ${dry_labels:-none}]"
      _BEAD_SYNC_RESULT="created"; return
    fi

    local create_args=(--repo "$repo" --title "$title" --body "$body")
    while IFS= read -r lbl; do
      [[ -n "$lbl" ]] && create_args+=(--label "$lbl")
    done <<< "$labels_raw"
    [[ -n "$assignee" ]] && create_args+=(--assignee "$assignee")

    local gh_response
    if ! gh_response=$(gh issue create "${create_args[@]}" 2>&1); then
      log_error "  Failed to create issue '$title': $gh_response"
      return
    fi

    local gh_url gh_num_new
    gh_url=$(printf '%s' "$gh_response" | grep -Eo 'https://github\.com/[^ ]+' | head -1)
    gh_num_new=$(printf '%s' "$gh_url" | grep -Eo '[0-9]+$')

    # Close immediately if bead status is closed
    [[ "$gh_state" == "closed" && -n "$gh_num_new" ]] && \
      gh issue close "$gh_num_new" --repo "$repo" &>/dev/null || true

    log_info "  Created: $gh_url"

    # Write back GitHub metadata into the bead via bd update --metadata
    local new_meta
    new_meta=$(printf '%s' "$bd_raw_json" | jq -c \
      --arg     num  "$gh_num_new" \
      --arg     url  "$gh_url" \
      --arg     sync "$now" \
      --arg     hash "$current_hash" \
      '(.metadata // {}) + {
        github_issue_number:      ($num | if . != "" then tonumber else null end),
        github_issue_url:         $url,
        github_issue_synced_at:   $sync,
        github_issue_synced_hash: $hash
      }')
    bd update "$bd_id" --metadata "$new_meta" -q 2>/dev/null \
      || log_warn "  Could not write back GitHub metadata to bead $bd_id"

    _BEAD_SYNC_RESULT="created"; return
  fi

  # ---- UPDATE existing issue -----------------------------------------------
  local synced_hash
  synced_hash=$(printf '%s' "$bd_raw_json" | jq -r '.metadata.github_issue_synced_hash // ""')

  if [[ "$current_hash" == "$synced_hash" && "$force_update" != true ]]; then
    log_debug "  Issue #$gh_number unchanged â€” skipped"
    _BEAD_SYNC_RESULT="skipped"; return
  fi

  log_info "  Updating issue #$gh_number: $title"

  if [[ "$DRY_RUN" == true ]]; then
    log_dry "  Would update #$gh_number: $title"
    _BEAD_SYNC_RESULT="updated"; return
  fi

  # Use REST API for updates (gh issue edit --add-label doesn't replace labels)
  local labels_json_arr
  labels_json_arr=$(labels_to_json_array "$labels_raw")

  local patch_data=()
  patch_data+=(-f  title="$title")
  patch_data+=(-f  body="$body")
  patch_data+=(-f  state="$gh_state")
  [[ -n "$milestone_id" ]] && patch_data+=(-F milestone="$milestone_id")

  if ! gh api "repos/${repo}/issues/${gh_number}" \
        --method PATCH "${patch_data[@]}" --silent; then
    log_error "  Failed to update issue #$gh_number"
    return
  fi

  # Replace labels atomically via the labels endpoint
  if printf '%s' "$labels_json_arr" | jq -e 'length > 0' &>/dev/null; then
    gh api "repos/${repo}/issues/${gh_number}/labels" \
      --method PUT \
      --input <(printf '%s' "$labels_json_arr" | jq '{labels: .}') \
      --silent &>/dev/null || log_warn "  Could not update labels on #$gh_number"
  fi

  # Set assignee
  if [[ -n "$assignee" ]]; then
    gh api "repos/${repo}/issues/${gh_number}/assignees" \
      --method POST \
      -F "assignees[]=$assignee" \
      --silent &>/dev/null || log_warn "  Could not set assignee on #$gh_number"
  fi

  log_info "  Updated: https://github.com/${repo}/issues/${gh_number}"

  # Write back updated sync metadata into the bead via bd update --metadata
  local new_meta
  new_meta=$(printf '%s' "$bd_raw_json" | jq -c \
    --arg sync "$now" \
    --arg hash "$current_hash" \
    '(.metadata // {}) + {
      github_issue_synced_at:   $sync,
      github_issue_synced_hash: $hash
    }')
  bd update "$bd_id" --metadata "$new_meta" -q 2>/dev/null \
    || log_warn "  Could not write back sync metadata to bead $bd_id"

  _BEAD_SYNC_RESULT="updated"
}

_run_gh_sync() {
  local repo="$1"
  local force_update="$2"

  [[ "$repo" =~ ^[^/]+/[^/]+$ ]] || die "Invalid --repo format (expected owner/name): $repo"

  [[ "$DRY_RUN" != true ]] && check_bd_dep
  [[ "$DRY_RUN" != true ]] && check_bd_init
  [[ "$DRY_RUN" != true ]] && check_bd_stale
  [[ "$DRY_RUN" != true ]] && check_gh_dep

  log_info "Repository : $repo"
  [[ "$DRY_RUN"      == true ]] && log_warn "Dry-run mode â€” no changes will be made"
  [[ "$force_update" == true ]] && log_warn "Force mode  â€” all issues will be updated"

  # Fetch beads from the bd database (all beads or speckit-only depending on --all-beads)
  local beads_list
  if [[ "$ALL_BEADS" == true ]]; then
    beads_list=$(bd list --all --limit 0 --json 2>/dev/null || true)
  else
    beads_list=$(bd list --all --limit 0 -l speckit --json 2>/dev/null || true)
  fi

  if [[ -z "$beads_list" || "$beads_list" == "[]" || "$beads_list" == "null" ]]; then
    if [[ -f ".beads/issues.jsonl" ]]; then
      log_warn "bd database is empty but .beads/issues.jsonl exists."
      log_warn "Run: bd import -i .beads/issues.jsonl  then retry."
    else
      log_warn "No beads found.  Run: bdim create first."
    fi
    return 0
  fi

  # Sort so non-epics come first: children get GitHub issue numbers before
  # the epic body is built, enabling real #N links in the task list.
  local sorted_beads_json
  sorted_beads_json=$(printf '%s' "$beads_list" | jq -c \
    '(map(select(.metadata.is_epic != true)) + map(select(.metadata.is_epic == true)))' \
    2>/dev/null || printf '%s' "$beads_list")

  local created=0 updated=0 skipped=0 failed=0 bead_count=0

  while IFS= read -r bead_item; do
    local bd_id
    bd_id=$(printf '%s' "$bead_item" | jq -r '.id // empty')
    [[ -z "$bd_id" ]] && continue

    # Fetch full bead details â€” list output may omit description/notes/metadata
    local full_bead_json
    if ! full_bead_json=$(bd_get_bead_json "$bd_id") || [[ -z "$full_bead_json" ]]; then
      log_warn "Could not fetch bead details for: $bd_id"
      (( failed++ )); continue
    fi

    (( bead_count++ ))

    # For epic beads: build the children list from the pre-fetched beads_list,
    # and always force-update so the task list stays current with #N links.
    local children_list_json=""
    local bead_is_epic sync_force
    bead_is_epic=$(printf '%s' "$full_bead_json" | jq -r '.metadata.is_epic // false')
    sync_force="$force_update"

    if [[ "$bead_is_epic" == "true" ]]; then
      local epic_ext_ref
      epic_ext_ref=$(printf '%s' "$full_bead_json" | jq -r '.external_ref // ""')
      children_list_json=$(printf '%s' "$beads_list" | jq -c \
        --arg pref "$epic_ext_ref" \
        '[.[] | select(.metadata.parent_external_ref == $pref) | {
          task_id:             (.metadata.task_id // ""),
          title:               .title,
          github_issue_number: (.metadata.github_issue_number // null)
        }]' 2>/dev/null || echo "[]")
      sync_force="true"  # Always rebuild epic body (children may have gained #N links)
    fi

    _BEAD_SYNC_RESULT="failed"
    _sync_one_bead "$repo" "$full_bead_json" "$bd_id" "$sync_force" "$children_list_json" || true

    case "$_BEAD_SYNC_RESULT" in
      created) (( created++ )) ;;
      updated) (( updated++ )) ;;
      skipped) (( skipped++ )) ;;
      *)       (( failed++  )) ;;
    esac
  done < <(printf '%s' "$sorted_beads_json" | jq -c '.[]' 2>/dev/null)

  if [[ $bead_count -eq 0 ]]; then
    log_warn "No beads found to sync."
    return 0
  fi

  printf '\n'
  log_info "Sync complete â€” created: $created, updated: $updated, skipped: $skipped, failed: $failed"

  # Keep .beads/issues.jsonl current (captures github_issue_* metadata write-backs)
  [[ $(( created + updated )) -gt 0 ]] && bd_export_jsonl

  [[ $failed -eq 0 ]] || { log_error "$failed bead(s) failed to sync"; return 1; }
}

cmd_convert() {
  local repo=""
  local force_update=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo|-r)    repo="$2";         shift 2 ;;
      --force)      force_update=true; shift ;;
      --dry-run)    DRY_RUN=true;      shift ;;
      --all-beads)  ALL_BEADS=true;    shift ;;
      --verbose|-v) VERBOSE=true;      shift ;;
      -*)           die "Unknown option: $1" ;;
      *)            die "Unexpected argument: $1" ;;
    esac
  done

  [[ -n "$repo" ]] || die_usage "Usage: bdim convert --repo owner/name"

  _run_gh_sync "$repo" "$force_update"
}

cmd_sync() { cmd_convert "$@"; }

# =============================================================================
# STATUS REPORT
# =============================================================================

cmd_status() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --all-beads)  ALL_BEADS=true;  shift ;;
      --verbose|-v) VERBOSE=true;    shift ;;
      -*)           die "Unknown option: $1" ;;
      *)            break ;;
    esac
  done

  check_bd_dep
  check_bd_init

  local beads_list
  if [[ "$ALL_BEADS" == true ]]; then
    beads_list=$(bd list --all --limit 0 --json 2>/dev/null || true)
  else
    beads_list=$(bd list --all --limit 0 -l speckit --json 2>/dev/null || true)
  fi

  if [[ -z "$beads_list" || "$beads_list" == "[]" || "$beads_list" == "null" ]]; then
    if [[ -f ".beads/issues.jsonl" ]]; then
      log_warn "bd database is empty but .beads/issues.jsonl exists."
      log_warn "Run: bd import -i .beads/issues.jsonl  then try again."
    else
      log_warn "No beads found.  Run: bdim create first."
    fi
    return 0
  fi

  local total=0 synced=0 pending=0

  printf '%-20s %-48s %-14s %-12s %s\n' "Bead ID" "Title" "Status" "GH Issue" "Synced?"
  printf '%s\n' "$(printf '%0.sâ”€' {1..110})"

  while IFS= read -r bead_item; do
    local bd_id
    bd_id=$(printf '%s' "$bead_item" | jq -r '.id // empty')
    [[ -z "$bd_id" ]] && continue

    local full_json
    full_json=$(bd_get_bead_json "$bd_id") || continue
    [[ -z "$full_json" ]] && continue

    local title status gh_num synced_hash content_hash
    title=$(printf '%s'        "$full_json" | jq -r '.title                              // "(untitled)"')
    status=$(printf '%s'       "$full_json" | jq -r '.status                             // "?"')
    gh_num=$(printf '%s'       "$full_json" | jq -r '.metadata.github_issue_number       // "-"')
    synced_hash=$(printf '%s'  "$full_json" | jq -r '.metadata.github_issue_synced_hash  // ""')
    content_hash=$(printf '%s' "$full_json" | jq -r '.metadata.content_hash              // ""')

    local sync_state
    if [[ "$gh_num" == "-" || "$gh_num" == "null" ]]; then
      sync_state="not synced"
      (( pending++ ))
    elif [[ "$synced_hash" != "$content_hash" ]]; then
      sync_state="needs update"
      (( pending++ ))
    else
      sync_state="up to date"
      (( synced++ ))
    fi

    (( total++ ))
    printf '%-20s %-48s %-14s %-12s %s\n' \
      "$bd_id" \
      "$(printf '%s' "$title" | cut -c1-47)" \
      "$status" \
      "#$gh_num" \
      "$sync_state"
  done < <(printf '%s' "$beads_list" | jq -c '.[]' 2>/dev/null)

  printf '\n'
  log_info "Total: $total | Synced: $synced | Needs sync: $pending"
}

# =============================================================================
# INIT
# =============================================================================

cmd_init() {
  local dry_run_flag=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run)    dry_run_flag=true; DRY_RUN=true; shift ;;
      --verbose|-v) VERBOSE=true;                    shift ;;
      -*)           die "Unknown option: $1" ;;
      *)            die_usage "init takes no positional arguments" ;;
    esac
  done

  check_specify_dep
  check_bd_dep

  # â”€â”€ spec-kit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if [[ -f "constitution.md" ]] || [[ -d "specs" ]]; then
    log_info "spec-kit already initialised â€” skipping specify init."
  else
    log_info "Initialising spec-kit project..."
    if [[ "$DRY_RUN" == true ]]; then
      log_dry "Would run: specify init --here --ai claude --force"
    else
      specify init --here --ai claude --force \
        || die "specify init failed."
      log_info "spec-kit project initialised."
    fi
  fi

  # â”€â”€ bd database â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  local already_init=false
  if bd list --limit 1 --json &>/dev/null 2>&1; then
    already_init=true
  fi

  if [[ "$already_init" == true ]]; then
    log_info "bd database already initialised â€” skipping bd init."
  else
    log_info "Initialising bd database..."
    if [[ "$DRY_RUN" == true ]]; then
      log_dry "Would run: bd init"
    else
      bd init || die "bd init failed."
      log_info "bd database initialised."
    fi
  fi

  # â”€â”€ .gitignore â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if git rev-parse --git-dir &>/dev/null 2>&1; then
    local gitignore=".gitignore"
    local entry_dolt=".beads/dolt/"
    local entry_db=".beads/*.db"
    local needs_dolt=true
    local needs_db=true

    if [[ -f "$gitignore" ]]; then
      grep -qF "$entry_dolt" "$gitignore" 2>/dev/null && needs_dolt=false
      grep -qF "$entry_db"   "$gitignore" 2>/dev/null && needs_db=false
    fi

    if [[ "$needs_dolt" == true ]] || [[ "$needs_db" == true ]]; then
      if [[ "$DRY_RUN" == true ]]; then
        [[ "$needs_dolt" == true ]] && log_dry "Would add to .gitignore: $entry_dolt"
        [[ "$needs_db"   == true ]] && log_dry "Would add to .gitignore: $entry_db"
      else
        if [[ "$needs_dolt" == true ]]; then
          printf '\n# bd (Beads) â€” binary database, never commit\n%s\n' "$entry_dolt" >> "$gitignore"
          log_info "Added $entry_dolt to .gitignore"
        fi
        if [[ "$needs_db" == true ]]; then
          printf '%s\n' "$entry_db" >> "$gitignore"
          log_info "Added $entry_db to .gitignore"
        fi
      fi
    else
      log_info ".gitignore already contains bd entries â€” no changes needed."
    fi
  fi

  printf '\n'
  log_info "Setup complete. Next steps:"
  log_info "  1. Run /speckit.tasks in your spec-kit project to generate tasks.md"
  log_info "  2. bdim speckit-to-beads"
  log_info "  3. bdim sync --repo owner/my-project"
}

# =============================================================================
# TEAM WORKFLOW â€” latest / update
# =============================================================================

# Pull the latest shared bead database from git and import it into the local
# bd database.  Replaces the manual two-step:
#   git pull && bd import -i .beads/issues.jsonl
cmd_latest() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run)    DRY_RUN=true;  shift ;;
      --verbose|-v) VERBOSE=true;  shift ;;
      -*)           die "Unknown option: $1" ;;
      *)            die_usage "latest takes no positional arguments" ;;
    esac
  done

  git rev-parse --git-dir &>/dev/null 2>&1 \
    || die "Not a git repository.  Run bdim latest from your project root."

  [[ "$DRY_RUN" != true ]] && check_bd_dep
  [[ "$DRY_RUN" != true ]] && check_bd_init

  # â”€â”€ Step 1: git pull â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  log_info "Pulling latest changes from remote..."
  if [[ "$DRY_RUN" == true ]]; then
    log_dry "Would run: git pull"
  else
    if ! git pull; then
      die "git pull failed.  Resolve any conflicts, then re-run bdim latest."
    fi
    log_info "  git pull complete."
  fi

  # â”€â”€ Step 2: bd import â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  local jsonl_path=".beads/issues.jsonl"
  if [[ "$DRY_RUN" != true && ! -f "$jsonl_path" ]]; then
    log_warn "$jsonl_path not found â€” nothing to import."
    log_warn "Run 'bdim create' to generate beads, then share $jsonl_path via git."
    return 0
  fi

  log_info "Importing beads from $jsonl_path..."
  if [[ "$DRY_RUN" == true ]]; then
    log_dry "Would run: bd import -i $jsonl_path"
  else
    if ! bd import -i "$jsonl_path"; then
      die "bd import failed.  Check that $jsonl_path is a valid JSONL file."
    fi
    log_info "  Import complete."
  fi

  log_info "Bead database is up to date."
}

# Export the bead database, stage .beads/issues.jsonl, commit, and push.
# Replaces the manual three-step:
#   git add .beads/issues.jsonl && git commit -m "..." && git push
cmd_update() {
  local commit_msg="Update beads"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --message|-m) commit_msg="$2"; shift 2 ;;
      --dry-run)    DRY_RUN=true;    shift ;;
      --verbose|-v) VERBOSE=true;    shift ;;
      -*)           die "Unknown option: $1" ;;
      *)            die_usage "update takes no positional arguments" ;;
    esac
  done

  git rev-parse --git-dir &>/dev/null 2>&1 \
    || die "Not a git repository.  Run bdim update from your project root."

  [[ "$DRY_RUN" != true ]] && check_bd_dep
  [[ "$DRY_RUN" != true ]] && check_bd_init

  local jsonl_path=".beads/issues.jsonl"

  # â”€â”€ Step 1: bd export (ensure JSONL reflects current state of bd) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  log_info "Exporting bead database â†’ $jsonl_path"
  if [[ "$DRY_RUN" == true ]]; then
    log_dry "Would run: bd export -o $jsonl_path -q"
  else
    if ! bd export -o "$jsonl_path" -q 2>/dev/null; then
      die "bd export failed.  Ensure bd is initialised (bdim init)."
    fi
    log_info "  Export complete."
  fi

  # â”€â”€ Step 2: check for changes (skip commit if nothing changed) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if [[ "$DRY_RUN" != true ]]; then
    if [[ -z "$(git status --porcelain "$jsonl_path" 2>/dev/null)" ]]; then
      log_info "No changes to $jsonl_path â€” nothing to commit."
      return 0
    fi
  fi

  # â”€â”€ Step 3: git add â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  log_info "Staging $jsonl_path..."
  if [[ "$DRY_RUN" == true ]]; then
    log_dry "Would run: git add $jsonl_path"
  else
    git add "$jsonl_path"
  fi

  # â”€â”€ Step 4: git commit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  log_info "Committing: \"$commit_msg\""
  if [[ "$DRY_RUN" == true ]]; then
    log_dry "Would run: git commit -m \"$commit_msg\""
  else
    if ! git commit -m "$commit_msg"; then
      die "git commit failed."
    fi
  fi

  # â”€â”€ Step 5: git push â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  log_info "Pushing to remote..."
  if [[ "$DRY_RUN" == true ]]; then
    log_dry "Would run: git push"
  else
    if ! git push; then
      die "git push failed.  Try: bdim latest  then re-run bdim update."
    fi
    log_info "  Pushed successfully."
  fi

  log_info "Bead database shared with team."
}

# =============================================================================
# USAGE
# =============================================================================

show_usage() {
  cat <<EOF
${BOLD}bdim${RESET} v${VERSION}  â€”  spec-kit tasks.md â†’ Beads â†’ GitHub Issues

${BOLD}USAGE${RESET}
  bdim <command> [options]

${BOLD}COMMANDS${RESET}

  ${CYAN}init${RESET}
    Initialise the bd database in the current directory and add bd entries to
    .gitignore.  Idempotent â€” safe to run multiple times.

      --dry-run        Preview without writing anything
      --verbose, -v    Verbose output

  ${CYAN}create${RESET}  [--project ID]
    Read all tasks.md files under specs/*/tasks.md (auto-discovered) and
    create or update Beads in the local bd database.  Each task line becomes
    a Bead tagged with label 'speckit'.  Idempotent â€” re-running only touches
    tasks that have changed.

      --project, -p ID Override the project namespace (only valid when one
                       tasks.md is found)
      --dry-run        Preview without calling bd
      --verbose, -v    Verbose output

  ${CYAN}convert${RESET}  --repo owner/name
    Push Beads (label=speckit) to GitHub Issues.  Creates new issues and
    updates existing ones.  Manual GitHub edits are preserved unless --force.

      --repo, -r REPO  GitHub repo, e.g. acme/my-project  (required)
      --force          Override GitHub edits; always push Bead content
      --dry-run        Preview without touching GitHub
      --all-beads      Include all beads, not just speckit-labelled ones
      --verbose, -v    Verbose output

  ${CYAN}sync${RESET}  --repo owner/name
    Alias for convert.  Only pushes Beads whose content has changed.

      Same options as convert.

  ${CYAN}status${RESET}
    Print a table of all Beads (label=speckit) and their GitHub sync state.

      --all-beads      Include all beads regardless of label (default: speckit-labelled only)
      --verbose, -v    Verbose output

  ${CYAN}latest${RESET}
    Pull the latest shared bead database from git and import it into the local
    bd database.  Equivalent to:
      git pull && bd import -i .beads/issues.jsonl

      --dry-run        Preview without running git or bd
      --verbose, -v    Verbose output

  ${CYAN}update${RESET}  [--message MSG]
    Export the bead database, stage .beads/issues.jsonl, commit, and push.
    Equivalent to:
      git add .beads/issues.jsonl && git commit -m "..." && git push
    Re-exports first to ensure the file is current.  Skips the commit if
    .beads/issues.jsonl has not changed.

      --message, -m MSG  Commit message (default: "Update beads")
      --dry-run          Preview without running git or bd
      --verbose, -v      Verbose output

${BOLD}ENVIRONMENT VARIABLES${RESET}

  GITHUB_TOKEN    Optional â€” gh CLI manages auth by default (gh auth login)

${BOLD}DEPENDENCIES${RESET}

  Required: bash â‰¥ 3.2, jq, gh (GitHub CLI), bd (Beads CLI)
  macOS:    shasum (built-in)  or  sha256sum

  Install: brew install jq gh
           npm i -g @beads/bd   (or: brew install beads)

${BOLD}TEAM WORKFLOW (multi-machine)${RESET}

  bdim auto-exports .beads/issues.jsonl after every write command so the
  bead database can be committed to git and shared with your team.

  Setup â€” add to your project's .gitignore:
    .beads/dolt/          â† binary Dolt DB, never commit
    .beads/*.db

  Workflow for each team member:
    bdim latest                    â† git pull + bd import (get shared beads)
    bdim create                    â† creates/updates beads + auto-exports
    bdim sync --repo ...           â† pushes to GitHub   + auto-exports
    bdim update                    â† bd export + git add + commit + push

${BOLD}EXIT CODES${RESET}

  0   Success
  1   Runtime error (e.g. a bead failed to sync)
  2   Usage / argument error

${BOLD}EXAMPLES${RESET}

  # First-time project setup:
  ./bdim init

  # Phase 1 â€” run /speckit.tasks to generate specs/*/tasks.md, then:
  ./bdim create
  ./bdim create --dry-run
  ./bdim create --project myproject   # single spec only

  # Phase 2 â€” push Beads to GitHub Issues
  ./bdim convert --repo acme/my-project --dry-run
  ./bdim convert --repo acme/my-project

  # Ongoing â€” sync only changed Beads (idempotent)
  ./bdim sync --repo acme/my-project

  # Force-push all Beads (overrides manual GitHub edits)
  ./bdim sync --repo acme/my-project --force

  # Check sync state without touching anything
  ./bdim status

${BOLD}SOURCE OF TRUTH MODEL${RESET}

  1. spec-kit /speckit.tasks generates specs/*/tasks.md
  2. bdim create reads those files and creates Beads in bd.
  3. After Beads exist in bd, Beads are the source of truth.
  4. GitHub Issues are read-only projections of Beads.
  5. GitHub edits do NOT override Beads (unless --force is used).
  6. Changes flow:
       Phase 1:  /speckit.tasks â†’ tasks.md â†’ bdim create â†’ bd
       Phase 2:  bd Beads â†’ bdim sync â†’ GitHub Issues

EOF
}

# =============================================================================
# MAIN
# =============================================================================

main() {
  check_core_deps

  [[ $# -gt 0 ]] || { show_usage; exit 0; }

  local cmd="$1"; shift

  case "$cmd" in
    init)             cmd_init    "$@" ;;
    create)           cmd_create  "$@" ;;
    convert)          cmd_convert "$@" ;;
    sync)             cmd_sync    "$@" ;;
    status|st)        cmd_status  "$@" ;;
    latest)           cmd_latest  "$@" ;;
    update)           cmd_update  "$@" ;;
    version|--version|-V)   printf 'bdim v%s\n' "$VERSION"; exit 0 ;;
    help|--help|-h)         show_usage; exit 0 ;;
    *)
      log_error "Unknown command: $cmd"
      show_usage
      exit 2
      ;;
  esac
}

main "$@"
