#!/usr/bin/env bash
# =============================================================================
# beadsync — spec-kit tasks.md → Beads → GitHub Issues workflow bridge
# Version  : 3.0.0
# Requires : bash ≥ 3.2, jq, gh (GitHub CLI), bd (Beads CLI)
# =============================================================================
# SOURCE OF TRUTH MODEL
#   Phase 1 — spec-kit is canonical.  Run: /speckit.tasks → generates tasks.md
#              Then: beadsync speckit-to-beads  (auto-reads .specify/specs/*/tasks.md)
#   Phase 2 — Beads are canonical.   Run: beads-to-gh / sync
#   GitHub Issues are read-only projections of Beads.
#   GitHub edits do NOT flow back into Beads unless --force is used.
# =============================================================================

set -euo pipefail
IFS=$'\n\t'

VERSION="3.0.0"

# ---------------------------------------------------------------------------
# Colours (disabled when not a TTY)
# ---------------------------------------------------------------------------
if [[ -t 1 ]]; then
  RED='\033[0;31m'; YELLOW='\033[1;33m'; GREEN='\033[0;32m'
  BLUE='\033[0;34m'; CYAN='\033[0;36m'; BOLD='\033[1m'; RESET='\033[0m'
else
  RED=''; YELLOW=''; GREEN=''; BLUE=''; CYAN=''; BOLD=''; RESET=''
fi

# ---------------------------------------------------------------------------
# Global flags
# ---------------------------------------------------------------------------
DRY_RUN=false
VERBOSE=false
ALL_BEADS=false

# =============================================================================
# LOGGING
# =============================================================================

log_info()  { printf "${GREEN}[INFO]${RESET}  %s\n"  "$*"; }
log_warn()  { printf "${YELLOW}[WARN]${RESET}  %s\n"  "$*" >&2; }
log_error() { printf "${RED}[ERROR]${RESET} %s\n"  "$*" >&2; }
log_debug() { [[ "$VERBOSE" == true ]] && printf "${CYAN}[DEBUG]${RESET} %s\n" "$*" || true; }
log_dry()   { printf "${BLUE}[DRY]${RESET}   %s\n"  "$*"; }

die()       { log_error "$*"; exit 1; }
die_usage() { log_error "$*"; exit 2; }

# =============================================================================
# DEPENDENCY CHECKS
# =============================================================================

check_core_deps() {
  local missing=()
  command -v jq      &>/dev/null || missing+=("jq  (brew install jq)")
  # macOS ships shasum; Linux ships sha256sum
  { command -v sha256sum &>/dev/null || command -v shasum &>/dev/null; } \
    || missing+=("sha256sum / shasum")
  [[ ${#missing[@]} -eq 0 ]] || die "Missing dependencies: ${missing[*]}"
}

check_gh_dep() {
  command -v gh &>/dev/null || die "gh (GitHub CLI) required.  Install: brew install gh"
  if ! gh auth status &>/dev/null 2>&1; then
    die "gh is not authenticated.  Run: gh auth login"
  fi
}

check_bd_dep() {
  command -v bd &>/dev/null \
    || die "bd (Beads CLI) required.  Install: npm i -g @beads/bd  (or: brew install beads)"
}

# Verify that a bd database has been initialised in (or above) the current
# directory.  Called after check_bd_dep so the error is targeted rather than
# a raw bd failure message.
check_bd_init() {
  if ! bd list --limit 1 --json &>/dev/null 2>&1; then
    die "No bd database found in this directory." \
        $'\n       ''Run '\''bd init'\'' in your project root, then try again.'
  fi
}

# Warn when .beads/issues.jsonl exists but the local bd database is empty.
# This almost always means the user forgot `bd import` after a `git pull`.
# Non-fatal — we warn and let the command continue so the user can decide.
check_bd_stale() {
  [[ -f ".beads/issues.jsonl" ]] || return 0  # no JSONL → nothing to check

  local count
  count=$(bd list --all --limit 1 --json 2>/dev/null | jq 'length' 2>/dev/null || echo "0")

  if [[ "$count" == "0" ]]; then
    log_warn "bd database is empty but .beads/issues.jsonl exists."
    log_warn "Did you forget to run: bd import -i .beads/issues.jsonl"
    log_warn "Continuing — beads will be created fresh from this run."
  fi
}

# =============================================================================
# BD DATABASE EXPORT
# =============================================================================

# Export the full bd database to .beads/issues.jsonl so it can be committed
# to git and shared with the team.  Non-fatal — a warning is emitted on failure
# so the rest of the command still reports its summary correctly.
bd_export_jsonl() {
  local jsonl_path=".beads/issues.jsonl"

  if [[ "$DRY_RUN" == true ]]; then
    log_dry "Would export bead database → $jsonl_path"
    return 0
  fi

  log_info "Exporting bead database → $jsonl_path"

  if ! bd export -o "$jsonl_path" -q 2>&1; then
    log_warn "Could not export bead database to $jsonl_path"
    return 0  # non-fatal; sync state is still correct in bd
  fi

  log_info "  Done.  Commit $jsonl_path to share beads with your team."
  log_info "  Others can load it with: bd import -i $jsonl_path"
}

# =============================================================================
# UTILITIES
# =============================================================================

# Portable SHA-256 → hex string of any stdin
_sha256() { command -v sha256sum &>/dev/null && sha256sum | awk '{print $1}' \
              || shasum -a 256 | awk '{print $1}'; }

sha256_of() { printf '%s' "$1" | _sha256; }

iso8601_now() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }

require_file() { [[ -f "$1" ]] || die "File not found: $1"; }

validate_json_file() {
  jq empty "$1" 2>/dev/null || die "Invalid JSON in file: $1"
}

# =============================================================================
# FIELD MAPPING: Speckit → Bead
# =============================================================================

# Portable lowercase (works with bash 3.2 shipped on macOS)
lc() { printf '%s' "$1" | tr '[:upper:]' '[:lower:]'; }

# Speckit priority string → Bead integer (P0–P4)
map_priority() {
  case "$(lc "$1")" in
    critical|p0|0)          echo 0 ;;
    high|p1|1)              echo 1 ;;
    medium|normal|p2|2)     echo 2 ;;
    low|p3|3)               echo 3 ;;
    none|trivial|p4|4|*)    echo 4 ;;
  esac
}

# Speckit status string → Bead status enum
map_status() {
  case "$(lc "$1")" in
    pending|todo|backlog|open|new|not_started)           echo "open" ;;
    in_progress|in-progress|active|started|wip|doing)   echo "in_progress" ;;
    done|complete|completed|closed|resolved|finished)   echo "closed" ;;
    blocked|on_hold|on-hold|waiting)                    echo "blocked" ;;
    deferred|postponed|later|icebox)                    echo "deferred" ;;
    cancelled|canceled|wontfix|wont_fix|abandoned)      echo "closed" ;;
    *)                                                  echo "open" ;;
  esac
}

# Map status string to Bead close_reason when applicable
map_close_reason() {
  case "$(lc "$1")" in
    cancelled|canceled|wontfix|wont_fix)   echo "wontfix" ;;
    abandoned)                              echo "abandoned" ;;
    done|complete|completed|resolved)       echo "completed" ;;
    *)                                      echo "" ;;
  esac
}

# Speckit type string → Bead issue_type enum
map_type() {
  case "$(lc "$1")" in
    task|tasks|work)                       echo "task" ;;
    bug|defect|issue|error)               echo "bug" ;;
    feature|enhancement|feat|story|us)    echo "feature" ;;
    epic|theme|initiative|program)        echo "epic" ;;
    chore|maintenance|infra|tech_debt|dx) echo "chore" ;;
    decision|adr|dec|rfc)                 echo "decision" ;;
    *)                                    echo "task" ;;
  esac
}

# spec-kit user story number → Bead priority (US1=P1/high … none=P2/medium)
map_us_priority() {
  case "$1" in
    US1)          echo 1 ;;
    US2)          echo 2 ;;
    US[3-9]|US1[0-9]*) echo 3 ;;
    *)            echo 2 ;;   # setup / foundational / polish
  esac
}

# =============================================================================
# BEAD IDENTITY
# =============================================================================

# Stable external_ref derived deterministically from project + task ID.
# Format: "speckit-<project-id>-<task-id>"
# Scopes identity to the project, preventing cross-project collisions.
# Used as:
#   • the bd external_ref field (idempotency key for bd)
#   • the HTML comment anchor in GitHub issue bodies
compute_external_ref() {
  local project_id="$1"
  local task_id="$2"
  printf 'speckit-%s-%s' "$project_id" "$task_id"
}

# Content hash of key Bead fields (excludes sync-state metadata).
# A change in this hash means the Bead needs to be pushed to GitHub.
compute_content_hash() {
  local hash_json="$1"
  local canonical
  canonical=$(printf '%s' "$hash_json" | jq -c '{
    title, status, priority, issue_type, labels
  }')
  sha256_of "$canonical"
}

# =============================================================================
# BD HELPERS
# =============================================================================

# Get a single bead's full JSON from bd by its ID.
# Always returns a single JSON object (handles both object and array responses).
bd_get_bead_json() {
  local bd_id="$1"
  bd show "$bd_id" --json 2>/dev/null \
    | jq -c 'if type == "array" then .[0] else . end' 2>/dev/null
}

# Adapt bd show --json output to the internal format that format_gh_body expects.
# Maps bd field names → the field names beadsync uses internally.
bd_json_to_internal() {
  local bd_json="$1"
  jq -c '{
    title:                .title,
    description:          .description,
    acceptance_criteria:  (.acceptance_criteria // .acceptance),
    notes:                .notes,
    spec_id:              (.metadata.speckit_id // .external_ref),
    external_id:          .external_ref,
    due_at:               .due_at,
    assignee:             .assignee,
    estimated_minutes:    (.estimated_minutes // 0),
    issue_type:           (.issue_type // .type // "task"),
    priority:             (.priority // 2),
    status:               (.status // "open"),
    labels:               (.labels // []),
    metadata:             (.metadata // {})
  }' <<< "$bd_json"
}

# =============================================================================
# SPEC-KIT tasks.md → BEADS  (Phase 1)
# =============================================================================

# ---------------------------------------------------------------------------
# spec-kit tasks.md line format:
#   - [ ] T001 Description with file path
#   - [ ] T005 [P] Implement auth middleware in src/middleware/auth.py
#   - [x] T012 [P] [US1] Create User model in src/models/user.py
#   - [ ] T014 [US1] Implement UserService in src/services/user_service.py
#
# Components:
#   - [ ] or - [x]  checkbox (open / closed)
#   T\d+            task ID  (T001, T002, …)
#   [P]             optional — task is parallelisable
#   [US\d+]         optional — maps to user story (US1, US2, …)
#   rest of line    description / title
#
# All other lines (headers, blank lines, comments, dependency sections) are
# silently skipped.
#
# Auto-discovery: specs/*/tasks.md relative to CWD.
# spec-kit places tasks.md at specs/<NNN-branch-name>/tasks.md in the repo root.
# Project ID per file: folder name with leading NNN- stripped and normalised.
# ---------------------------------------------------------------------------

# Derive a normalised project ID from a spec-kit feature folder name.
# Input:  "specs/001-my-feature"
# Output: "my-feature"
_project_id_from_folder() {
  local folder
  folder=$(basename "$1")
  # Strip leading NNN- numeric prefix (e.g. "001-")
  folder=$(printf '%s' "$folder" | sed 's/^[0-9]*-//')
  # Normalise: lowercase, collapse non-alnum runs to dash, trim edges
  printf '%s' "$folder" \
    | tr '[:upper:]' '[:lower:]' \
    | tr -cs 'a-z0-9' '-' \
    | sed 's/^-//;s/-$//'
}

_process_tasks_file() {
  local tasks_file="$1"
  local project_id="$2"

  local created=0 updated=0 skipped=0 failed=0 task_count=0

  log_info "tasks.md     : $tasks_file"
  log_info "Project ID   : $project_id"

  # Pre-fetch the full speckit bead list once for O(1) idempotency lookups.
  local _all_beads_json=""
  [[ "$DRY_RUN" != true ]] && \
    _all_beads_json=$(bd list --all --limit 0 -l speckit --json 2>/dev/null || true)

  while IFS= read -r line; do

    # Match checklist lines only: - [ ] T001 ... or - [x] T001 ...
    [[ "$line" =~ ^[[:space:]]*-[[:space:]]\[([[:space:]x])\][[:space:]]+(T[0-9]+)(.*) ]] \
      || continue

    local checked="${BASH_REMATCH[1]}"
    local task_id="${BASH_REMATCH[2]}"
    local rest="${BASH_REMATCH[3]}"

    # Markers [P] and [US\d+] always appear immediately after the task ID,
    # before the description.  Parse positionally from the left so that [P]
    # inside description text (e.g. "(ID, [P], [US#], status)") is ignored.

    # Trim leading whitespace first
    rest=$(printf '%s' "$rest" | sed 's/^[[:space:]]*//')

    # Extract optional [P] parallelism marker (only if at start of rest)
    local parallel=false
    if printf '%s' "$rest" | grep -qE '^\[P\]([[:space:]]|$)'; then
      parallel=true
      rest=$(printf '%s' "$rest" | sed 's/^\[P\][[:space:]]*//')
    fi

    # Extract optional [US\d+] user-story marker (only if at start of rest)
    local user_story=""
    if printf '%s' "$rest" | grep -qE '^\[US[0-9]+\]([[:space:]]|$)'; then
      user_story=$(printf '%s' "$rest" | grep -oE '^\[US[0-9]+\]' | tr -d '[]' || true)
      rest=$(printf '%s' "$rest" | sed 's/^\[US[0-9]*\][[:space:]]*//')
    fi

    # Trim whitespace from description
    local title
    title=$(printf '%s' "$rest" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

    if [[ -z "$title" ]]; then
      log_warn "Skipping $task_id: empty description"
      failed=$(( failed + 1 )); continue
    fi

    task_count=$(( task_count + 1 ))

    # ---- Map fields --------------------------------------------------------
    local bead_status bead_priority
    [[ "$checked" == "x" ]] && bead_status="closed" || bead_status="open"
    bead_priority=$(map_us_priority "$user_story")

    # Labels: speckit (always) + user story (if any) + parallel (if flagged)
    local all_labels="speckit"
    [[ -n "$user_story" ]] && all_labels+=",$user_story"
    [[ "$parallel" == true ]] && all_labels+=",parallel"

    local labels_json
    labels_json=$(printf '%s' "$all_labels" | tr ',' '\n' \
      | jq -Rc '[inputs | select(length > 0)]')

    # ---- Content hash ------------------------------------------------------
    local external_ref content_hash hash_json
    external_ref=$(compute_external_ref "$project_id" "$task_id")
    hash_json=$(jq -cn \
      --arg  title      "$title" \
      --arg  status     "$bead_status" \
      --argjson priority "$bead_priority" \
      --arg  issue_type "task" \
      --argjson labels  "$labels_json" \
      '{title, status, priority, issue_type, labels}')
    content_hash=$(compute_content_hash "$hash_json")

    log_debug "Processing $task_id → external_ref: $external_ref"

    # ---- Idempotency: check for existing bead in bd ------------------------
    local bd_id=""
    [[ "$DRY_RUN" != true ]] && bd_id=$(printf '%s' "$_all_beads_json" \
      | jq -r --arg ref "$external_ref" '.[]? | select(.external_ref == $ref) | .id' \
      | head -1)

    # ---- Base metadata -----------------------------------------------------
    local parallel_bool="false"
    [[ "$parallel" == true ]] && parallel_bool="true"

    local base_meta_json
    base_meta_json=$(jq -cn \
      --arg  ch  "$content_hash" \
      --arg  tid "$task_id" \
      --arg  us  "$user_story" \
      --argjson p "$parallel_bool" \
      '{
        source_system: "speckit",
        speckit_id:    $tid,
        task_id:       $tid,
        content_hash:  $ch,
        user_story:    (if $us != "" then $us else null end),
        parallel:      $p
      } | with_entries(select(.value != null))')

    # ========================================================================
    # CREATE — no existing bead found
    # ========================================================================
    if [[ -z "$bd_id" ]]; then

      if [[ "$DRY_RUN" == true ]]; then
        local us_tag=""
        [[ -n "$user_story" ]] && us_tag=" [$user_story]"
        [[ "$parallel" == true ]] && us_tag+=" [P]"
        log_dry "Would create: [$task_id / P${bead_priority}${us_tag}] $title"
        created=$(( created + 1 )); continue
      fi

      log_info "Creating bead: $task_id — $title"

      local create_args=("$title")
      create_args+=(--external-ref "$external_ref")
      create_args+=(-l "$all_labels")
      create_args+=(-p "$bead_priority")
      create_args+=(-t "task")
      create_args+=(--silent)

      local new_bd_id
      if ! new_bd_id=$(bd create "${create_args[@]}" 2>/dev/null); then
        log_error "Failed to create bead for $task_id"
        failed=$(( failed + 1 )); continue
      fi
      new_bd_id=$(printf '%s' "$new_bd_id" | tr -d '[:space:]')

      # Set closed status if task was already checked off
      if [[ "$bead_status" == "closed" ]]; then
        bd update "$new_bd_id" -s "closed" -q 2>/dev/null \
          || log_warn "Could not set status 'closed' on $new_bd_id"
      fi

      bd update "$new_bd_id" --metadata "$base_meta_json" -q 2>/dev/null \
        || log_warn "Could not set metadata on $new_bd_id"

      log_info "  Created: $new_bd_id"
      created=$(( created + 1 ))

    else
    # ========================================================================
    # UPDATE or SKIP — bead already exists
    # ========================================================================

      local existing_json existing_hash
      existing_json=$(bd_get_bead_json "$bd_id")
      existing_hash=$(printf '%s' "$existing_json" \
        | jq -r '.metadata.content_hash // ""' 2>/dev/null || true)

      if [[ "$existing_hash" == "$content_hash" ]]; then
        log_debug "Bead $external_ref unchanged — skipped"
        skipped=$(( skipped + 1 )); continue
      fi

      log_info "Updating bead: $bd_id  ($external_ref)"

      local update_args=("$bd_id")
      update_args+=(--title "$title")
      update_args+=(-p "$bead_priority")
      update_args+=(-t "task")
      update_args+=(-s "$bead_status")
      update_args+=(--set-labels "$all_labels")
      update_args+=(-q)

      if ! bd update "${update_args[@]}" 2>/dev/null; then
        log_error "Failed to update bead $bd_id"
        failed=$(( failed + 1 )); continue
      fi

      # Preserve existing GitHub sync fields when rebuilding metadata
      local gh_num gh_url gh_synced gh_synced_hash
      gh_num=$(printf '%s'         "$existing_json" | jq -r '.metadata.github_issue_number      // ""')
      gh_url=$(printf '%s'         "$existing_json" | jq -r '.metadata.github_issue_url         // ""')
      gh_synced=$(printf '%s'      "$existing_json" | jq -r '.metadata.github_issue_synced_at   // ""')
      gh_synced_hash=$(printf '%s' "$existing_json" | jq -r '.metadata.github_issue_synced_hash // ""')

      local full_meta_json
      full_meta_json=$(printf '%s' "$base_meta_json" | jq -c \
        --arg ghu  "$gh_url" \
        --arg ghs  "$gh_synced" \
        --arg ghsh "$gh_synced_hash" \
        '. +
        (if $ghu  != "" then {github_issue_url:         $ghu}  else {} end) +
        (if $ghs  != "" then {github_issue_synced_at:   $ghs}  else {} end) +
        (if $ghsh != "" then {github_issue_synced_hash: $ghsh} else {} end)')

      if [[ -n "$gh_num" && "$gh_num" != "null" ]]; then
        full_meta_json=$(printf '%s' "$full_meta_json" \
          | jq -c --argjson n "$gh_num" '. + {github_issue_number: $n}')
      fi

      bd update "$bd_id" --metadata "$full_meta_json" -q 2>/dev/null \
        || log_warn "Could not update metadata on $bd_id"

      log_info "  Updated: $bd_id"
      updated=$(( updated + 1 ))
    fi

  done < "$tasks_file"

  printf '\n'
  log_info "  Tasks parsed : $task_count  |  created: $created, updated: $updated, skipped: $skipped, failed: $failed"

  # Return counters via globals so caller can accumulate across files
  _S2B_CREATED=$(( _S2B_CREATED + created ))
  _S2B_UPDATED=$(( _S2B_UPDATED + updated ))
  _S2B_FAILED=$((  _S2B_FAILED  + failed  ))
}

# Global accumulators for _process_tasks_file
_S2B_CREATED=0
_S2B_UPDATED=0
_S2B_FAILED=0

cmd_speckit_to_beads() {
  local project_id_flag=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project|-p)   project_id_flag="$2"; shift 2 ;;
      --dry-run)      DRY_RUN=true;         shift ;;
      --verbose|-v)   VERBOSE=true;         shift ;;
      -*)             die "Unknown option: $1" ;;
      *)              die_usage "speckit-to-beads takes no positional arguments — tasks.md files are auto-discovered under specs/" ;;
    esac
  done

  [[ "$DRY_RUN" != true ]] && check_bd_dep
  [[ "$DRY_RUN" != true ]] && check_bd_init
  [[ "$DRY_RUN" != true ]] && check_bd_stale

  # Discover all tasks.md files under specs/*/  (spec-kit default layout)
  local tasks_files=()
  while IFS= read -r f; do
    [[ -f "$f" ]] && tasks_files+=("$f")
  done < <(find specs -mindepth 2 -maxdepth 2 -name tasks.md 2>/dev/null | sort)

  if [[ ${#tasks_files[@]} -eq 0 ]]; then
    die "No tasks.md files found under specs/." \
        $'\n       ''Run /speckit.tasks to generate a tasks.md first.'
  fi

  # --project only makes sense when there is exactly one file
  if [[ -n "$project_id_flag" && ${#tasks_files[@]} -gt 1 ]]; then
    die "--project can only be used when there is a single tasks.md (found ${#tasks_files[@]})"
  fi

  log_info "Found ${#tasks_files[@]} tasks.md file(s)"
  [[ "$DRY_RUN" == true ]] && log_warn "Dry-run mode — no beads will be created or updated"

  _S2B_CREATED=0; _S2B_UPDATED=0; _S2B_FAILED=0

  local f project_id
  for f in "${tasks_files[@]}"; do
    if [[ -n "$project_id_flag" ]]; then
      project_id="$project_id_flag"
    else
      project_id=$(_project_id_from_folder "$(dirname "$f")")
    fi
    _process_tasks_file "$f" "$project_id"
  done

  printf '\n'
  log_info "speckit-to-beads complete — created: $_S2B_CREATED, updated: $_S2B_UPDATED, failed: $_S2B_FAILED"
  [[ "$DRY_RUN" == true ]] && log_warn "Dry-run — no beads were created or updated."

  [[ $(( _S2B_CREATED + _S2B_UPDATED )) -gt 0 ]] && bd_export_jsonl

  [[ $_S2B_FAILED -eq 0 ]] || return 1
}

# =============================================================================
# GITHUB BODY FORMATTER
# =============================================================================

# Produces a clean GitHub Markdown issue body.
# The hidden HTML comment <!-- beadsync:external_id:... --> is the idempotency
# anchor used by find_gh_issue_by_external_id().
# Expects the internal bead format produced by bd_json_to_internal().
format_gh_body() {
  local bead_json="$1"

  local task_id external_id title priority
  task_id=$(printf '%s'    "$bead_json" | jq -r '.metadata.task_id  // ""')
  external_id=$(printf '%s' "$bead_json" | jq -r '.external_id       // ""')
  title=$(printf '%s'      "$bead_json" | jq -r '.title              // ""')
  priority=$(printf '%s'   "$bead_json" | jq -r '.priority           // 2')

  local body=""

  # spec-kit task bead — task_id is the primary identifier
  if [[ -n "$task_id" ]]; then
    local user_story parallel
    user_story=$(printf '%s' "$bead_json" | jq -r '.metadata.user_story // ""')
    parallel=$(printf '%s'   "$bead_json" | jq -r '.metadata.parallel   // false')

    local summary="\`${task_id}\`"
    [[ -n "$user_story"      ]] && summary+=" · User Story: ${user_story}"
    [[ "$parallel" == "true" ]] && summary+=" · Parallel: yes"

    body+="## Task\n\n${summary}\n\n"
    body+="---\n\n"
    body+="| Field | Value |\n"
    body+="| --- | --- |\n"
    body+="| Task ID | \`${task_id}\` |\n"
    [[ -n "$user_story"      ]] && body+="| User Story | \`${user_story}\` |\n"
    body+="| Priority | P${priority} |\n"
    [[ "$parallel" == "true" ]] && body+="| Parallel | yes |\n"

  else
    # Legacy / non-task bead
    local description acc_criteria notes spec_id due_at assignee estimated_minutes milestone
    description=$(printf '%s'       "$bead_json" | jq -r '.description          // ""')
    acc_criteria=$(printf '%s'      "$bead_json" | jq -r '.acceptance_criteria  // ""')
    notes=$(printf '%s'             "$bead_json" | jq -r '.notes                // ""')
    spec_id=$(printf '%s'           "$bead_json" | jq -r '.spec_id              // ""')
    due_at=$(printf '%s'            "$bead_json" | jq -r '.due_at               // ""')
    assignee=$(printf '%s'          "$bead_json" | jq -r '.assignee             // ""')
    estimated_minutes=$(printf '%s' "$bead_json" | jq -r '.estimated_minutes    // 0')
    milestone=$(printf '%s'         "$bead_json" | jq -r '.metadata.milestone   // ""')

    [[ -n "$description" ]]  && body+="## Description\n\n${description}\n\n"
    [[ -n "$acc_criteria" ]] && body+="## Acceptance Criteria\n\n${acc_criteria}\n\n"
    [[ -n "$notes" ]]        && body+="## Notes\n\n${notes}\n\n"

    body+="---\n\n"
    body+="| Field | Value |\n"
    body+="| --- | --- |\n"
    [[ -n "$spec_id" ]]  && body+="| Speckit ID | \`${spec_id}\` |\n"
    body+="| Priority | P${priority} |\n"
    [[ -n "$due_at"    ]] && body+="| Due date | \`${due_at}\` |\n"
    [[ -n "$milestone" ]] && body+="| Milestone | ${milestone} |\n"
    [[ -n "$assignee"  ]] && body+="| Assignee | @${assignee} |\n"

    if [[ "$estimated_minutes" -gt 0 ]]; then
      local h=$(( estimated_minutes / 60 ))
      local m=$(( estimated_minutes % 60 ))
      local est=""
      [[ $h -gt 0 ]] && est+="${h}h"
      [[ $m -gt 0 ]] && est+=" ${m}m"
      body+="| Estimate | \`${est}\` |\n"
    fi
  fi

  body+="\n_Managed by [beadsync](https://github.com/steveyegge/beads). "
  body+="Edit the Bead, not this issue._\n\n"
  # Idempotency anchor — DO NOT REMOVE
  body+="<!-- beadsync:external_id:${external_id} -->"

  printf '%b' "$body"
}

# =============================================================================
# GITHUB HELPERS
# =============================================================================

# Search GitHub for an issue whose body contains the idempotency anchor.
# Returns the issue number, or empty string if not found.
find_gh_issue_by_external_id() {
  local repo="$1"
  local external_id="$2"

  log_debug "Searching GitHub for external_id: $external_id"

  local query="repo:${repo} in:body beadsync:external_id:${external_id}"
  gh api "search/issues" \
    --method GET \
    -f q="$query" \
    --jq '.items[0].number // empty' 2>/dev/null || true
}

# Ensure a label exists in the repo, creating it with a random colour if not.
ensure_label_exists() {
  local repo="$1"
  local label="$2"
  [[ -z "$label" ]] && return 0

  if ! gh api "repos/${repo}/labels" --jq ".[].name" 2>/dev/null \
        | grep -qxF "$label"; then
    log_debug "Creating label: $label"
    local colour
    colour=$(printf '%06X' $(( RANDOM % 16777215 )))
    gh api "repos/${repo}/labels" \
      --method POST \
      -f name="$label" \
      -f color="$colour" \
      --silent &>/dev/null || log_warn "Could not create label: $label"
  fi
}

# Resolve a milestone title to its numeric ID (or empty string).
get_milestone_id() {
  local repo="$1"
  local title="$2"
  [[ -z "$title" ]] && return 0
  gh api "repos/${repo}/milestones" \
    --jq ".[] | select(.title == \"${title}\") | .number" \
    2>/dev/null | head -1 || true
}

# Build a JSON array of labels from a newline-separated list.
labels_to_json_array() {
  local labels_raw="$1"
  printf '%s' "$labels_raw" | jq -Rc '[inputs | select(length > 0)]'
}

# =============================================================================
# BEADS → GITHUB  (Phase 2)
# =============================================================================

# ---------------------------------------------------------------------------
# Field mapping contract — Bead → GitHub Issue
#
# Bead field               GitHub field        Notes
# ─────────────────────────────────────────────────────────────────────────
# title                  → title              direct
# description            → body (section)     composed markdown
# acceptance_criteria    → body (section)     composed markdown
# notes                  → body (section)     composed markdown
# spec_id (metadata)     → body (table row)   reference only
# external_ref           → body (HTML comment) idempotency anchor
# labels[]               → labels[]           created if missing
# assignee               → assignees[0]       single assignee
# metadata.milestone     → milestone.title    resolved to milestone number
# status == "closed"     → state = "closed"   open otherwise
# metadata.github_issue_number ← stored back via bd update --metadata
# metadata.github_issue_url    ← stored back via bd update --metadata
# metadata.github_issue_synced_at   ← timestamp of last successful sync
# metadata.github_issue_synced_hash ← content_hash at last sync
# ---------------------------------------------------------------------------

# Global used by _sync_one_bead to avoid stdout pollution in subshells.
_BEAD_SYNC_RESULT=""

_sync_one_bead() {
  local repo="$1"
  local bd_raw_json="$2"   # raw JSON from bd show --json (single object)
  local bd_id="$3"
  local force_update="$4"
  # Sets _BEAD_SYNC_RESULT to: "created" | "updated" | "skipped" | "failed"

  _BEAD_SYNC_RESULT="failed"

  # Adapt bd JSON to the internal format that format_gh_body expects
  local bead_json
  bead_json=$(bd_json_to_internal "$bd_raw_json")

  local external_id title
  external_id=$(printf '%s' "$bead_json" | jq -r '.external_id // ""')
  title=$(printf '%s'       "$bead_json" | jq -r '.title       // ""')

  if [[ -z "$external_id" || -z "$title" ]]; then
    log_warn "Bead $bd_id missing external_ref or title — skipped"
    return
  fi

  log_debug "Syncing bead: $bd_id  ($external_id)"

  # ---- Resolve existing GitHub issue number (skipped in dry-run) -----------
  local gh_number=""
  local stored_number
  stored_number=$(printf '%s' "$bd_raw_json" | jq -r '.metadata.github_issue_number // empty')

  if [[ -n "$stored_number" && "$stored_number" != "null" ]]; then
    gh_number="$stored_number"
    log_debug "  Stored issue number: #$gh_number"
  elif [[ "$DRY_RUN" != true ]]; then
    gh_number=$(find_gh_issue_by_external_id "$repo" "$external_id")
    [[ -n "$gh_number" ]] && log_debug "  Found via search: #$gh_number"
  fi

  # ---- Prepare GitHub payload ----------------------------------------------
  local body
  body=$(format_gh_body "$bead_json")

  local labels_raw
  labels_raw=$(printf '%s' "$bead_json" | jq -r '.labels // [] | .[]' 2>/dev/null)

  local assignee
  assignee=$(printf '%s' "$bead_json" | jq -r '.assignee // ""')

  local bead_status gh_state
  bead_status=$(printf '%s' "$bead_json" | jq -r '.status // "open"')
  [[ "$bead_status" == "closed" ]] && gh_state="closed" || gh_state="open"

  # ---- Ensure labels exist (skip in dry-run) -------------------------------
  if [[ "$DRY_RUN" != true ]]; then
    while IFS= read -r lbl; do
      [[ -n "$lbl" ]] && ensure_label_exists "$repo" "$lbl"
    done <<< "$labels_raw"
  fi

  # ---- Milestone (skip in dry-run) -----------------------------------------
  local milestone_title milestone_id=""
  milestone_title=$(printf '%s' "$bead_json" | jq -r '.metadata.milestone // ""')
  if [[ -n "$milestone_title" && "$DRY_RUN" != true ]]; then
    milestone_id=$(get_milestone_id "$repo" "$milestone_title")
  fi

  local now
  now=$(iso8601_now)
  local current_hash
  current_hash=$(printf '%s' "$bd_raw_json" | jq -r '.metadata.content_hash // ""')

  # ---- CREATE new issue ----------------------------------------------------
  if [[ -z "$gh_number" ]]; then
    log_info "  Creating issue: $title"

    if [[ "$DRY_RUN" == true ]]; then
      local dry_labels
      dry_labels=$(printf '%s' "$labels_raw" | tr '\n' ' ')
      log_dry "  Would create: $title  [labels: ${dry_labels:-none}]"
      _BEAD_SYNC_RESULT="created"; return
    fi

    local create_args=(--repo "$repo" --title "$title" --body "$body")
    while IFS= read -r lbl; do
      [[ -n "$lbl" ]] && create_args+=(--label "$lbl")
    done <<< "$labels_raw"
    [[ -n "$assignee" ]] && create_args+=(--assignee "$assignee")

    local gh_response
    if ! gh_response=$(gh issue create "${create_args[@]}" 2>&1); then
      log_error "  Failed to create issue '$title': $gh_response"
      return
    fi

    local gh_url gh_num_new
    gh_url=$(printf '%s' "$gh_response" | grep -Eo 'https://github\.com/[^ ]+' | head -1)
    gh_num_new=$(printf '%s' "$gh_url" | grep -Eo '[0-9]+$')

    # Close immediately if bead status is closed
    [[ "$gh_state" == "closed" && -n "$gh_num_new" ]] && \
      gh issue close "$gh_num_new" --repo "$repo" &>/dev/null || true

    log_info "  Created: $gh_url"

    # Write back GitHub metadata into the bead via bd update --metadata
    local new_meta
    new_meta=$(printf '%s' "$bd_raw_json" | jq -c \
      --arg     num  "$gh_num_new" \
      --arg     url  "$gh_url" \
      --arg     sync "$now" \
      --arg     hash "$current_hash" \
      '(.metadata // {}) + {
        github_issue_number:      ($num | if . != "" then tonumber else null end),
        github_issue_url:         $url,
        github_issue_synced_at:   $sync,
        github_issue_synced_hash: $hash
      }')
    bd update "$bd_id" --metadata "$new_meta" -q 2>/dev/null \
      || log_warn "  Could not write back GitHub metadata to bead $bd_id"

    _BEAD_SYNC_RESULT="created"; return
  fi

  # ---- UPDATE existing issue -----------------------------------------------
  local synced_hash
  synced_hash=$(printf '%s' "$bd_raw_json" | jq -r '.metadata.github_issue_synced_hash // ""')

  if [[ "$current_hash" == "$synced_hash" && "$force_update" != true ]]; then
    log_debug "  Issue #$gh_number unchanged — skipped"
    _BEAD_SYNC_RESULT="skipped"; return
  fi

  log_info "  Updating issue #$gh_number: $title"

  if [[ "$DRY_RUN" == true ]]; then
    log_dry "  Would update #$gh_number: $title"
    _BEAD_SYNC_RESULT="updated"; return
  fi

  # Use REST API for updates (gh issue edit --add-label doesn't replace labels)
  local labels_json_arr
  labels_json_arr=$(labels_to_json_array "$labels_raw")

  local patch_data=()
  patch_data+=(-f  title="$title")
  patch_data+=(-f  body="$body")
  patch_data+=(-f  state="$gh_state")
  [[ -n "$milestone_id" ]] && patch_data+=(-F milestone="$milestone_id")

  if ! gh api "repos/${repo}/issues/${gh_number}" \
        --method PATCH "${patch_data[@]}" --silent; then
    log_error "  Failed to update issue #$gh_number"
    return
  fi

  # Replace labels atomically via the labels endpoint
  if printf '%s' "$labels_json_arr" | jq -e 'length > 0' &>/dev/null; then
    gh api "repos/${repo}/issues/${gh_number}/labels" \
      --method PUT \
      --input <(printf '%s' "$labels_json_arr" | jq '{labels: .}') \
      --silent &>/dev/null || log_warn "  Could not update labels on #$gh_number"
  fi

  # Set assignee
  if [[ -n "$assignee" ]]; then
    gh api "repos/${repo}/issues/${gh_number}/assignees" \
      --method POST \
      -F "assignees[]=$assignee" \
      --silent &>/dev/null || log_warn "  Could not set assignee on #$gh_number"
  fi

  log_info "  Updated: https://github.com/${repo}/issues/${gh_number}"

  # Write back updated sync metadata into the bead via bd update --metadata
  local new_meta
  new_meta=$(printf '%s' "$bd_raw_json" | jq -c \
    --arg sync "$now" \
    --arg hash "$current_hash" \
    '(.metadata // {}) + {
      github_issue_synced_at:   $sync,
      github_issue_synced_hash: $hash
    }')
  bd update "$bd_id" --metadata "$new_meta" -q 2>/dev/null \
    || log_warn "  Could not write back sync metadata to bead $bd_id"

  _BEAD_SYNC_RESULT="updated"
}

_run_gh_sync() {
  local repo="$1"
  local force_update="$2"

  [[ "$repo" =~ ^[^/]+/[^/]+$ ]] || die "Invalid --repo format (expected owner/name): $repo"

  [[ "$DRY_RUN" != true ]] && check_bd_dep
  [[ "$DRY_RUN" != true ]] && check_bd_init
  [[ "$DRY_RUN" != true ]] && check_bd_stale
  [[ "$DRY_RUN" != true ]] && check_gh_dep

  log_info "Repository : $repo"
  [[ "$DRY_RUN"      == true ]] && log_warn "Dry-run mode — no changes will be made"
  [[ "$force_update" == true ]] && log_warn "Force mode  — all issues will be updated"

  # Fetch beads from the bd database (all beads or speckit-only depending on --all-beads)
  local beads_list
  if [[ "$ALL_BEADS" == true ]]; then
    beads_list=$(bd list --all --limit 0 --json 2>/dev/null || true)
  else
    beads_list=$(bd list --all --limit 0 -l speckit --json 2>/dev/null || true)
  fi

  if [[ -z "$beads_list" || "$beads_list" == "[]" || "$beads_list" == "null" ]]; then
    if [[ -f ".beads/issues.jsonl" ]]; then
      log_warn "bd database is empty but .beads/issues.jsonl exists."
      log_warn "Run: bd import -i .beads/issues.jsonl  then retry."
    else
      log_warn "No beads found.  Run: beadsync speckit-to-beads first."
    fi
    return 0
  fi

  local created=0 updated=0 skipped=0 failed=0 bead_count=0

  while IFS= read -r bead_item; do
    local bd_id
    bd_id=$(printf '%s' "$bead_item" | jq -r '.id // empty')
    [[ -z "$bd_id" ]] && continue

    # Fetch full bead details — list output may omit description/notes/metadata
    local full_bead_json
    if ! full_bead_json=$(bd_get_bead_json "$bd_id") || [[ -z "$full_bead_json" ]]; then
      log_warn "Could not fetch bead details for: $bd_id"
      (( failed++ )); continue
    fi

    (( bead_count++ ))

    _BEAD_SYNC_RESULT="failed"
    _sync_one_bead "$repo" "$full_bead_json" "$bd_id" "$force_update" || true

    case "$_BEAD_SYNC_RESULT" in
      created) (( created++ )) ;;
      updated) (( updated++ )) ;;
      skipped) (( skipped++ )) ;;
      *)       (( failed++  )) ;;
    esac
  done < <(printf '%s' "$beads_list" | jq -c '.[]' 2>/dev/null)

  if [[ $bead_count -eq 0 ]]; then
    log_warn "No beads found to sync."
    return 0
  fi

  printf '\n'
  log_info "Sync complete — created: $created, updated: $updated, skipped: $skipped, failed: $failed"

  # Keep .beads/issues.jsonl current (captures github_issue_* metadata write-backs)
  [[ $(( created + updated )) -gt 0 ]] && bd_export_jsonl

  [[ $failed -eq 0 ]] || { log_error "$failed bead(s) failed to sync"; return 1; }
}

cmd_beads_to_gh() {
  local repo=""
  local force_update=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo|-r)    repo="$2";        shift 2 ;;
      --force)      force_update=true; shift ;;
      --dry-run)    DRY_RUN=true;      shift ;;
      --all-beads)  ALL_BEADS=true;    shift ;;
      --verbose|-v) VERBOSE=true;      shift ;;
      -*)           die "Unknown option: $1" ;;
      *)            die "Unexpected argument '$1'.  Note: a beads directory is no longer required — beads are read directly from bd." ;;
    esac
  done

  [[ -n "$repo" ]] || die_usage "Usage: beadsync beads-to-gh --repo owner/name"

  _run_gh_sync "$repo" "$force_update"
}

cmd_sync() {
  local repo=""
  local force_update=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo|-r)    repo="$2";        shift 2 ;;
      --force)      force_update=true; shift ;;
      --dry-run)    DRY_RUN=true;      shift ;;
      --all-beads)  ALL_BEADS=true;    shift ;;
      --verbose|-v) VERBOSE=true;      shift ;;
      -*)           die "Unknown option: $1" ;;
      *)            die "Unexpected argument '$1'.  Note: a beads directory is no longer required — beads are read directly from bd." ;;
    esac
  done

  [[ -n "$repo" ]] || die_usage "Usage: beadsync sync --repo owner/name"

  _run_gh_sync "$repo" "$force_update"
}

# =============================================================================
# STATUS REPORT
# =============================================================================

cmd_status() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --all-beads)  ALL_BEADS=true;  shift ;;
      --verbose|-v) VERBOSE=true;    shift ;;
      -*)           die "Unknown option: $1" ;;
      *)            break ;;
    esac
  done

  check_bd_dep
  check_bd_init

  local beads_list
  if [[ "$ALL_BEADS" == true ]]; then
    beads_list=$(bd list --all --limit 0 --json 2>/dev/null || true)
  else
    beads_list=$(bd list --all --limit 0 -l speckit --json 2>/dev/null || true)
  fi

  if [[ -z "$beads_list" || "$beads_list" == "[]" || "$beads_list" == "null" ]]; then
    if [[ -f ".beads/issues.jsonl" ]]; then
      log_warn "bd database is empty but .beads/issues.jsonl exists."
      log_warn "Run: bd import -i .beads/issues.jsonl  then try again."
    else
      log_warn "No beads found.  Run: beadsync speckit-to-beads first."
    fi
    return 0
  fi

  local total=0 synced=0 pending=0

  printf '%-20s %-48s %-14s %-12s %s\n' "Bead ID" "Title" "Status" "GH Issue" "Synced?"
  printf '%s\n' "$(printf '%0.s─' {1..110})"

  while IFS= read -r bead_item; do
    local bd_id
    bd_id=$(printf '%s' "$bead_item" | jq -r '.id // empty')
    [[ -z "$bd_id" ]] && continue

    local full_json
    full_json=$(bd_get_bead_json "$bd_id") || continue
    [[ -z "$full_json" ]] && continue

    local title status gh_num synced_hash content_hash
    title=$(printf '%s'        "$full_json" | jq -r '.title                              // "(untitled)"')
    status=$(printf '%s'       "$full_json" | jq -r '.status                             // "?"')
    gh_num=$(printf '%s'       "$full_json" | jq -r '.metadata.github_issue_number       // "-"')
    synced_hash=$(printf '%s'  "$full_json" | jq -r '.metadata.github_issue_synced_hash  // ""')
    content_hash=$(printf '%s' "$full_json" | jq -r '.metadata.content_hash              // ""')

    local sync_state
    if [[ "$gh_num" == "-" || "$gh_num" == "null" ]]; then
      sync_state="not synced"
      (( pending++ ))
    elif [[ "$synced_hash" != "$content_hash" ]]; then
      sync_state="needs update"
      (( pending++ ))
    else
      sync_state="up to date"
      (( synced++ ))
    fi

    (( total++ ))
    printf '%-20s %-48s %-14s %-12s %s\n' \
      "$bd_id" \
      "$(printf '%s' "$title" | cut -c1-47)" \
      "$status" \
      "#$gh_num" \
      "$sync_state"
  done < <(printf '%s' "$beads_list" | jq -c '.[]' 2>/dev/null)

  printf '\n'
  log_info "Total: $total | Synced: $synced | Needs sync: $pending"
}

# =============================================================================
# USAGE
# =============================================================================

show_usage() {
  cat <<EOF
${BOLD}beadsync${RESET} v${VERSION}  —  spec-kit tasks.md → Beads → GitHub Issues

${BOLD}USAGE${RESET}
  beadsync <command> [options]

${BOLD}COMMANDS${RESET}

  ${CYAN}speckit-to-beads${RESET}  [--project ID]
    Read all tasks.md files under .specify/specs/*/tasks.md (auto-discovered)
    and create or update Beads in the local bd database.
    Each task line becomes a Bead tagged with label 'speckit'.
    Project ID is derived from the spec folder name (e.g. 001-my-feature → my-feature).
    Idempotent: re-running updates only changed tasks.

      --project, -p ID Override the project ID used to namespace Bead external
                       refs.  Only valid when a single tasks.md is found.
      --dry-run        Preview without calling bd
      --verbose, -v    Verbose output

  ${CYAN}beads-to-gh${RESET}  --repo owner/name
    Push Beads (label=speckit) to GitHub Issues.  Creates new issues and updates
    existing ones.  Manual GitHub edits are preserved unless --force.

      --repo, -r REPO  GitHub repo, e.g. acme/my-project  (required)
      --force          Override GitHub edits; always push Bead content
      --dry-run        Preview without touching GitHub
      --all-beads      Sync all beads regardless of label (default: speckit-labelled only)
      --verbose, -v    Verbose output

  ${CYAN}sync${RESET}  --repo owner/name
    Alias for beads-to-gh.  Only pushes Beads whose content has changed.

      Same options as beads-to-gh.

  ${CYAN}status${RESET}
    Print a table of all Beads (label=speckit) and their GitHub sync state.

      --all-beads      Include all beads regardless of label (default: speckit-labelled only)
      --verbose, -v    Verbose output

${BOLD}ENVIRONMENT VARIABLES${RESET}

  GITHUB_TOKEN    Optional — gh CLI manages auth by default (gh auth login)

${BOLD}DEPENDENCIES${RESET}

  Required: bash ≥ 3.2, jq, gh (GitHub CLI), bd (Beads CLI)
  macOS:    shasum (built-in)  or  sha256sum

  Install: brew install jq gh
           npm i -g @beads/bd   (or: brew install beads)

${BOLD}TEAM WORKFLOW (multi-machine)${RESET}

  beadsync auto-exports .beads/issues.jsonl after every write command so the
  bead database can be committed to git and shared with your team.

  Setup — add to your project's .gitignore:
    .beads/dolt/          ← binary Dolt DB, never commit
    .beads/*.db

  Commit the JSONL (one bead per line, git-mergeable):
    git add .beads/issues.jsonl && git commit -m "Update beads"

  Workflow for each team member:
    git pull
    bd import -i .beads/issues.jsonl   ← rebuild local Dolt DB
    beadsync speckit-to-beads          ← creates/updates beads + auto-exports
    beadsync sync --repo ...           ← pushes to GitHub   + auto-exports
    git add .beads/issues.jsonl && git commit && git push

${BOLD}EXIT CODES${RESET}

  0   Success
  1   Runtime error (e.g. a bead failed to sync)
  2   Usage / argument error

${BOLD}EXAMPLES${RESET}

  # Phase 1 — run /speckit.tasks first to generate .specify/specs/*/tasks.md
  # then import all tasks into bd:
  ./beadsync speckit-to-beads
  ./beadsync speckit-to-beads --dry-run
  ./beadsync speckit-to-beads --project myproject   # single spec only

  # Phase 2a — push all Beads to GitHub Issues (first time)
  ./beadsync beads-to-gh --repo acme/my-project --dry-run
  ./beadsync beads-to-gh --repo acme/my-project

  # Phase 2b — sync changed Beads (idempotent, run as often as needed)
  ./beadsync sync --repo acme/my-project

  # Force-push all Beads (overrides any manual GitHub edits)
  ./beadsync sync --repo acme/my-project --force

  # Check sync state without touching anything
  ./beadsync status

${BOLD}SOURCE OF TRUTH MODEL${RESET}

  1. spec-kit /speckit.tasks generates .specify/specs/*/tasks.md
  2. beadsync speckit-to-beads reads those files and creates Beads in bd.
  3. After Beads exist in bd, Beads are the source of truth.
  4. GitHub Issues are read-only projections of Beads.
  5. GitHub edits do NOT override Beads (unless --force is used).
  6. Changes flow:
       Phase 1:  /speckit.tasks → tasks.md → beadsync speckit-to-beads → bd
       Phase 2:  bd Beads → beadsync sync → GitHub Issues

EOF
}

# =============================================================================
# MAIN
# =============================================================================

main() {
  check_core_deps

  [[ $# -gt 0 ]] || { show_usage; exit 0; }

  local cmd="$1"; shift

  case "$cmd" in
    speckit-to-beads|s2b)   cmd_speckit_to_beads "$@" ;;
    beads-to-gh|b2g)        cmd_beads_to_gh "$@" ;;
    sync)                   cmd_sync "$@" ;;
    status|st)              cmd_status "$@" ;;
    version|--version|-V)   printf 'beadsync v%s\n' "$VERSION"; exit 0 ;;
    help|--help|-h)         show_usage; exit 0 ;;
    *)
      log_error "Unknown command: $cmd"
      show_usage
      exit 2
      ;;
  esac
}

main "$@"
