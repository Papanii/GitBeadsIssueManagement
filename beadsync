#!/usr/bin/env bash
# =============================================================================
# beadsync — Speckit → Beads → GitHub Issues workflow bridge
# Version  : 2.0.0
# Requires : bash ≥ 4.3, jq, gh (GitHub CLI), bd (Beads CLI)
# =============================================================================
# SOURCE OF TRUTH MODEL
#   Phase 1 — Speckit is canonical.  Run: speckit-to-beads
#   Phase 2 — Beads are canonical.   Run: beads-to-gh / sync
#   GitHub Issues are read-only projections of Beads.
#   GitHub edits do NOT flow back into Beads unless --force is used.
# =============================================================================

set -euo pipefail
IFS=$'\n\t'

VERSION="2.2.0"

# ---------------------------------------------------------------------------
# Colours (disabled when not a TTY)
# ---------------------------------------------------------------------------
if [[ -t 1 ]]; then
  RED='\033[0;31m'; YELLOW='\033[1;33m'; GREEN='\033[0;32m'
  BLUE='\033[0;34m'; CYAN='\033[0;36m'; BOLD='\033[1m'; RESET='\033[0m'
else
  RED=''; YELLOW=''; GREEN=''; BLUE=''; CYAN=''; BOLD=''; RESET=''
fi

# ---------------------------------------------------------------------------
# Global flags
# ---------------------------------------------------------------------------
DRY_RUN=false
VERBOSE=false

# =============================================================================
# LOGGING
# =============================================================================

log_info()  { printf "${GREEN}[INFO]${RESET}  %s\n"  "$*"; }
log_warn()  { printf "${YELLOW}[WARN]${RESET}  %s\n"  "$*" >&2; }
log_error() { printf "${RED}[ERROR]${RESET} %s\n"  "$*" >&2; }
log_debug() { [[ "$VERBOSE" == true ]] && printf "${CYAN}[DEBUG]${RESET} %s\n" "$*" || true; }
log_dry()   { printf "${BLUE}[DRY]${RESET}   %s\n"  "$*"; }

die()       { log_error "$*"; exit 1; }
die_usage() { log_error "$*"; exit 2; }

# =============================================================================
# DEPENDENCY CHECKS
# =============================================================================

check_core_deps() {
  local missing=()
  command -v jq      &>/dev/null || missing+=("jq  (brew install jq)")
  # macOS ships shasum; Linux ships sha256sum
  { command -v sha256sum &>/dev/null || command -v shasum &>/dev/null; } \
    || missing+=("sha256sum / shasum")
  [[ ${#missing[@]} -eq 0 ]] || die "Missing dependencies: ${missing[*]}"
}

check_gh_dep() {
  command -v gh &>/dev/null || die "gh (GitHub CLI) required.  Install: brew install gh"
  if ! gh auth status &>/dev/null 2>&1; then
    die "gh is not authenticated.  Run: gh auth login"
  fi
}

check_bd_dep() {
  command -v bd &>/dev/null \
    || die "bd (Beads CLI) required.  Install: npm i -g @beads/bd  (or: brew install beads)"
}

# Verify that a bd database has been initialised in (or above) the current
# directory.  Called after check_bd_dep so the error is targeted rather than
# a raw bd failure message.
check_bd_init() {
  if ! bd list --limit 1 --json &>/dev/null 2>&1; then
    die "No bd database found in this directory." \
        $'\n       ''Run '\''bd init'\'' in your project root, then try again.'
  fi
}

# Warn when .beads/issues.jsonl exists but the local bd database is empty.
# This almost always means the user forgot `bd import` after a `git pull`.
# Non-fatal — we warn and let the command continue so the user can decide.
check_bd_stale() {
  [[ -f ".beads/issues.jsonl" ]] || return 0  # no JSONL → nothing to check

  local count
  count=$(bd list --all --limit 1 --json 2>/dev/null | jq 'length' 2>/dev/null || echo "0")

  if [[ "$count" == "0" ]]; then
    log_warn "bd database is empty but .beads/issues.jsonl exists."
    log_warn "Did you forget to run: bd import -i .beads/issues.jsonl"
    log_warn "Continuing — beads will be created fresh from this run."
  fi
}

# =============================================================================
# BD DATABASE EXPORT
# =============================================================================

# Export the full bd database to .beads/issues.jsonl so it can be committed
# to git and shared with the team.  Non-fatal — a warning is emitted on failure
# so the rest of the command still reports its summary correctly.
bd_export_jsonl() {
  local jsonl_path=".beads/issues.jsonl"

  if [[ "$DRY_RUN" == true ]]; then
    log_dry "Would export bead database → $jsonl_path"
    return 0
  fi

  log_info "Exporting bead database → $jsonl_path"

  if ! bd export -o "$jsonl_path" -q 2>&1; then
    log_warn "Could not export bead database to $jsonl_path"
    return 0  # non-fatal; sync state is still correct in bd
  fi

  log_info "  Done.  Commit $jsonl_path to share beads with your team."
  log_info "  Others can load it with: bd import -i $jsonl_path"
}

# =============================================================================
# UTILITIES
# =============================================================================

# Portable SHA-256 → hex string of any stdin
_sha256() { command -v sha256sum &>/dev/null && sha256sum | awk '{print $1}' \
              || shasum -a 256 | awk '{print $1}'; }

sha256_of() { printf '%s' "$1" | _sha256; }

iso8601_now() { date -u +"%Y-%m-%dT%H:%M:%SZ"; }

require_file() { [[ -f "$1" ]] || die "File not found: $1"; }

validate_json_file() {
  jq empty "$1" 2>/dev/null || die "Invalid JSON in file: $1"
}

# =============================================================================
# FIELD MAPPING: Speckit → Bead
# =============================================================================

# Portable lowercase (works with bash 3.2 shipped on macOS)
lc() { printf '%s' "$1" | tr '[:upper:]' '[:lower:]'; }

# Speckit priority string → Bead integer (P0–P4)
map_priority() {
  case "$(lc "$1")" in
    critical|p0|0)          echo 0 ;;
    high|p1|1)              echo 1 ;;
    medium|normal|p2|2)     echo 2 ;;
    low|p3|3)               echo 3 ;;
    none|trivial|p4|4|*)    echo 4 ;;
  esac
}

# Speckit status string → Bead status enum
map_status() {
  case "$(lc "$1")" in
    pending|todo|backlog|open|new|not_started)           echo "open" ;;
    in_progress|in-progress|active|started|wip|doing)   echo "in_progress" ;;
    done|complete|completed|closed|resolved|finished)   echo "closed" ;;
    blocked|on_hold|on-hold|waiting)                    echo "blocked" ;;
    deferred|postponed|later|icebox)                    echo "deferred" ;;
    cancelled|canceled|wontfix|wont_fix|abandoned)      echo "closed" ;;
    *)                                                  echo "open" ;;
  esac
}

# Map status string to Bead close_reason when applicable
map_close_reason() {
  case "$(lc "$1")" in
    cancelled|canceled|wontfix|wont_fix)   echo "wontfix" ;;
    abandoned)                              echo "abandoned" ;;
    done|complete|completed|resolved)       echo "completed" ;;
    *)                                      echo "" ;;
  esac
}

# Speckit type string → Bead issue_type enum
map_type() {
  case "$(lc "$1")" in
    task|tasks|work)                       echo "task" ;;
    bug|defect|issue|error)               echo "bug" ;;
    feature|enhancement|feat|story|us)    echo "feature" ;;
    epic|theme|initiative|program)        echo "epic" ;;
    chore|maintenance|infra|tech_debt|dx) echo "chore" ;;
    decision|adr|dec|rfc)                 echo "decision" ;;
    *)                                    echo "task" ;;
  esac
}

# =============================================================================
# BEAD IDENTITY
# =============================================================================

# Stable external_ref derived deterministically from project + task ID.
# Format: "speckit-<project-id>-<task-id>"
# Scopes identity to the project, preventing cross-project collisions.
# Used as:
#   • the bd external_ref field (idempotency key for bd)
#   • the HTML comment anchor in GitHub issue bodies
compute_external_ref() {
  local project_id="$1"
  local task_id="$2"
  printf 'speckit-%s-%s' "$project_id" "$task_id"
}

# Content hash of key Bead fields (excludes sync-state metadata).
# A change in this hash means the Bead needs to be pushed to GitHub.
compute_content_hash() {
  local hash_json="$1"
  local canonical
  canonical=$(printf '%s' "$hash_json" | jq -c '{
    title, description, acceptance_criteria, notes,
    status, priority, issue_type, assignee, labels, due_at
  }')
  sha256_of "$canonical"
}

# =============================================================================
# BD HELPERS
# =============================================================================

# Find the bd issue ID for a given external_ref.
# Searches beads labeled 'speckit', then matches external_ref exactly.
# Prints the bd issue ID (e.g. "bd-abc123"), or nothing if not found.
bd_find_by_external_ref() {
  local external_ref="$1"
  bd list --all --limit 0 -l speckit --json 2>/dev/null \
    | jq -r --arg ref "$external_ref" \
        '.[] | select(.external_ref == $ref) | .id' \
    | head -1
}

# Get a single bead's full JSON from bd by its ID.
# Always returns a single JSON object (handles both object and array responses).
bd_get_bead_json() {
  local bd_id="$1"
  bd show "$bd_id" --json 2>/dev/null \
    | jq -c 'if type == "array" then .[0] else . end' 2>/dev/null
}

# Adapt bd show --json output to the internal format that format_gh_body expects.
# Maps bd field names → the field names beadsync uses internally.
bd_json_to_internal() {
  local bd_json="$1"
  jq -c '{
    title:                .title,
    description:          .description,
    acceptance_criteria:  (.acceptance_criteria // .acceptance),
    notes:                .notes,
    spec_id:              (.metadata.speckit_id // .external_ref),
    external_id:          .external_ref,
    due_at:               .due_at,
    assignee:             .assignee,
    estimated_minutes:    (.estimated_minutes // 0),
    issue_type:           (.issue_type // .type // "task"),
    priority:             (.priority // 2),
    status:               (.status // "open"),
    labels:               (.labels // []),
    metadata:             (.metadata // {})
  }' <<< "$bd_json"
}

# =============================================================================
# SPECKIT → BEADS  (Phase 1)
# =============================================================================

# ---------------------------------------------------------------------------
# Speckit export JSON schema (assumed):
# {
#   "export_version": "1.0",        // optional
#   "exported_at":    "<ISO8601>",   // optional
#   "project": { "id": "...", "name": "..." },  // optional
#   "tasks": [
#     {
#       "id":                   "<string>",   // REQUIRED — unique stable ID
#       "title":                "<string>",   // REQUIRED
#       "description":          "<string>",   // optional
#       "acceptance_criteria":  "<string>",   // optional
#       "notes":                "<string>",   // optional
#       "priority":             "<string>",   // optional: critical|high|medium|low|none
#       "status":               "<string>",   // optional: pending|in_progress|done|blocked|deferred|cancelled
#       "type":                 "<string>",   // optional: task|bug|feature|epic|chore|decision
#       "assignee":             "<string>",   // optional: GitHub username
#       "labels":               ["<string>"], // optional
#       "milestone":            "<string>",   // optional
#       "estimated_hours":      <number>,     // optional
#       "due_date":             "<YYYY-MM-DD>",// optional
#       "parent_id":            "<string>",   // optional — Speckit ID of parent task
#       "created_at":           "<ISO8601>",  // optional
#       "updated_at":           "<ISO8601>"   // optional
#     }
#   ]
# }
# ---------------------------------------------------------------------------

cmd_speckit_to_beads() {
  local speckit_file=""
  local project_id_flag=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project|-p)   project_id_flag="$2"; shift 2 ;;
      --dry-run)      DRY_RUN=true;         shift ;;
      --verbose|-v)   VERBOSE=true;         shift ;;
      -*)             die "Unknown option: $1" ;;
      *)
        [[ -z "$speckit_file" ]] && speckit_file="$1"
        shift ;;
    esac
  done

  [[ -n "$speckit_file" ]] || die_usage "Usage: beadsync speckit-to-beads <speckit_export.json> [--project ID]"
  require_file "$speckit_file"
  validate_json_file "$speckit_file"

  [[ "$DRY_RUN" != true ]] && check_bd_dep
  [[ "$DRY_RUN" != true ]] && check_bd_init
  [[ "$DRY_RUN" != true ]] && check_bd_stale

  # Validate that .tasks is an array
  local tasks_type task_count
  tasks_type=$(jq -r '.tasks | type' "$speckit_file" 2>/dev/null) \
    || die "Invalid Speckit JSON: cannot parse file"
  [[ "$tasks_type" == "array" ]] \
    || die "Invalid Speckit JSON: '.tasks' must be an array (got: ${tasks_type:-missing})"
  task_count=$(jq '.tasks | length' "$speckit_file")

  # Resolve project ID: --project flag > export's project.id > export's project.name > filename stem
  local project_id
  if [[ -n "$project_id_flag" ]]; then
    project_id="$project_id_flag"
  else
    project_id=$(jq -r '.project.id // .project.name // ""' "$speckit_file")
    if [[ -z "$project_id" ]]; then
      project_id=$(basename "$speckit_file" .json)
      log_warn "No project.id in export — using filename as project ID: $project_id"
      log_warn "Use --project <id> to set an explicit project ID."
    fi
  fi

  # Normalise: lowercase, collapse non-alphanumeric runs to single dash, trim edges
  project_id=$(printf '%s' "$project_id" \
    | tr '[:upper:]' '[:lower:]' \
    | tr -cs 'a-z0-9' '-' \
    | sed 's/^-//;s/-$//')

  log_info "Speckit export : $speckit_file"
  log_info "Project ID     : $project_id"
  log_info "Tasks found    : $task_count"
  [[ "$DRY_RUN" == true ]] && log_warn "Dry-run mode — no beads will be created or updated"

  local created=0 updated=0 skipped=0 failed=0

  while IFS= read -r task_json; do

    # ---- Required fields ---------------------------------------------------
    local speckit_id title
    speckit_id=$(printf '%s' "$task_json" | jq -r '.id // empty')
    if [[ -z "$speckit_id" ]]; then
      log_warn "Skipping task with no 'id' field"
      (( failed++ )); continue
    fi

    title=$(printf '%s' "$task_json" | jq -r '.title // empty')
    if [[ -z "$title" ]]; then
      log_warn "Skipping task $speckit_id: no 'title' field"
      (( failed++ )); continue
    fi

    # ---- Optional fields ---------------------------------------------------
    local description acc_criteria notes assignee milestone
    local estimated_hours due_date parent_id raw_status
    description=$(printf '%s'     "$task_json" | jq -r '.description          // ""')
    acc_criteria=$(printf '%s'    "$task_json" | jq -r '.acceptance_criteria  // ""')
    notes=$(printf '%s'           "$task_json" | jq -r '.notes                // ""')
    assignee=$(printf '%s'        "$task_json" | jq -r '.assignee             // ""')
    milestone=$(printf '%s'       "$task_json" | jq -r '.milestone            // ""')
    estimated_hours=$(printf '%s' "$task_json" | jq -r '.estimated_hours      // 0')
    due_date=$(printf '%s'        "$task_json" | jq -r '.due_date             // ""')
    parent_id=$(printf '%s'       "$task_json" | jq -r '.parent_id            // ""')
    raw_status=$(printf '%s'      "$task_json" | jq -r '.status               // "pending"')

    # ---- Mapped fields -----------------------------------------------------
    local bead_status bead_priority bead_type close_reason
    bead_status=$(map_status   "$(printf '%s' "$task_json" | jq -r '.status   // "pending"')")
    bead_priority=$(map_priority "$(printf '%s' "$task_json" | jq -r '.priority // "medium"')")
    bead_type=$(map_type       "$(printf '%s' "$task_json" | jq -r '.type     // "task"')")
    close_reason=$(map_close_reason "$raw_status")

    # estimated_minutes (integer arithmetic, avoid bc dependency)
    local estimated_minutes=0
    if [[ "$estimated_hours" != "0" && -n "$estimated_hours" ]]; then
      local eh_int
      eh_int=$(printf '%.0f' "$estimated_hours" 2>/dev/null || printf '%s' "$estimated_hours" | cut -d. -f1)
      estimated_minutes=$(( eh_int * 60 ))
    fi

    # due_at — append T00:00:00Z if only a date was provided
    local due_at=""
    if [[ -n "$due_date" ]]; then
      [[ "$due_date" =~ T ]] && due_at="$due_date" || due_at="${due_date}T00:00:00Z"
    fi

    # Labels: always include "speckit" as the base label for filtering,
    # plus any labels from the Speckit task
    local labels_json extra_labels all_labels
    labels_json=$(printf '%s' "$task_json" | jq -c '.labels // []')
    extra_labels=$(printf '%s' "$task_json" | jq -r '.labels // [] | .[]' 2>/dev/null)
    all_labels="speckit"
    while IFS= read -r lbl; do
      [[ -n "$lbl" ]] && all_labels+=",$lbl"
    done <<< "$extra_labels"

    # ---- Content hash (hashes key fields, excludes sync metadata) ----------
    local external_ref content_hash hash_json
    external_ref=$(compute_external_ref "$project_id" "$speckit_id")
    hash_json=$(jq -cn \
      --arg  title              "$title" \
      --arg  description        "$description" \
      --arg  acceptance_criteria "$acc_criteria" \
      --arg  notes              "$notes" \
      --arg  status             "$bead_status" \
      --argjson priority        "$bead_priority" \
      --arg  issue_type         "$bead_type" \
      --arg  assignee           "$assignee" \
      --argjson labels          "$labels_json" \
      --arg  due_at             "$due_at" \
      '{title, description, acceptance_criteria, notes,
        status, priority, issue_type, assignee, labels, due_at}')
    content_hash=$(compute_content_hash "$hash_json")

    log_debug "Processing $speckit_id → external_ref: $external_ref"

    # ---- Idempotency: check for existing bead in bd ------------------------
    local bd_id=""
    [[ "$DRY_RUN" != true ]] && bd_id=$(bd_find_by_external_ref "$external_ref")

    # ---- Base metadata (shared by create and update) -----------------------
    local base_meta_json
    base_meta_json=$(jq -cn \
      --arg ch  "$content_hash" \
      --arg sid "$speckit_id" \
      --arg ms  "$milestone" \
      --arg pid "$parent_id" \
      --arg cr  "$close_reason" \
      '{
        source_system:     "speckit",
        speckit_id:        $sid,
        content_hash:      $ch,
        milestone:         (if $ms  != "" then $ms  else null end),
        parent_speckit_id: (if $pid != "" then $pid else null end),
        close_reason:      (if $cr  != "" then $cr  else null end)
      } | with_entries(select(.value != null))')

    # ========================================================================
    # CREATE — no existing bead found
    # ========================================================================
    if [[ -z "$bd_id" ]]; then

      if [[ "$DRY_RUN" == true ]]; then
        log_dry "Would create bead: [$bead_type / P${bead_priority}] $title  ($external_ref)"
        (( created++ )); continue
      fi

      log_info "Creating bead: $title  ($external_ref)"

      local create_args=("$title")
      create_args+=(--external-ref "$external_ref")
      create_args+=(-l "$all_labels")
      create_args+=(-p "$bead_priority")
      create_args+=(-t "$bead_type")
      create_args+=(--silent)
      [[ -n "$description" ]]  && create_args+=(-d "$description")
      [[ -n "$acc_criteria" ]] && create_args+=(--acceptance "$acc_criteria")
      [[ -n "$notes" ]]        && create_args+=(--notes "$notes")
      [[ -n "$assignee" ]]     && create_args+=(-a "$assignee")
      [[ -n "$due_at" ]]       && create_args+=(--due "$due_at")
      [[ "$estimated_minutes" -gt 0 ]] && create_args+=(-e "$estimated_minutes")

      local new_bd_id
      if ! new_bd_id=$(bd create "${create_args[@]}" 2>&1); then
        log_error "Failed to create bead for $speckit_id: $new_bd_id"
        (( failed++ )); continue
      fi
      new_bd_id=$(printf '%s' "$new_bd_id" | tr -d '[:space:]')

      # Set non-open status (bd create always starts as open)
      if [[ "$bead_status" != "open" ]]; then
        bd update "$new_bd_id" -s "$bead_status" -q 2>/dev/null \
          || log_warn "Could not set status '$bead_status' on $new_bd_id"
      fi

      # Store metadata (content_hash + speckit fields; no GitHub fields yet)
      bd update "$new_bd_id" --metadata "$base_meta_json" -q 2>/dev/null \
        || log_warn "Could not set metadata on $new_bd_id"

      log_info "  Created: $new_bd_id"
      (( created++ ))

    else
    # ========================================================================
    # UPDATE or SKIP — bead already exists
    # ========================================================================

      local existing_json existing_hash
      existing_json=$(bd_get_bead_json "$bd_id")
      existing_hash=$(printf '%s' "$existing_json" \
        | jq -r '.metadata.content_hash // ""' 2>/dev/null || true)

      if [[ "$existing_hash" == "$content_hash" ]]; then
        log_debug "Bead $external_ref unchanged — skipped"
        (( skipped++ )); continue
      fi

      log_info "Updating bead: $bd_id  ($external_ref)"

      local update_args=("$bd_id")
      update_args+=(--title "$title")
      update_args+=(-p "$bead_priority")
      update_args+=(-t "$bead_type")
      update_args+=(-s "$bead_status")
      update_args+=(--set-labels "$all_labels")
      [[ -n "$description" ]]  && update_args+=(-d "$description")
      [[ -n "$acc_criteria" ]] && update_args+=(--acceptance "$acc_criteria")
      [[ -n "$notes" ]]        && update_args+=(--notes "$notes")
      [[ -n "$assignee" ]]     && update_args+=(-a "$assignee")
      [[ -n "$due_at" ]]       && update_args+=(--due "$due_at")
      [[ "$estimated_minutes" -gt 0 ]] && update_args+=(-e "$estimated_minutes")
      update_args+=(-q)

      if ! bd update "${update_args[@]}" 2>&1; then
        log_error "Failed to update bead $bd_id"
        (( failed++ )); continue
      fi

      # Preserve existing GitHub sync fields when rebuilding metadata
      local gh_num gh_url gh_synced gh_synced_hash
      gh_num=$(printf '%s'         "$existing_json" | jq -r '.metadata.github_issue_number      // ""')
      gh_url=$(printf '%s'         "$existing_json" | jq -r '.metadata.github_issue_url         // ""')
      gh_synced=$(printf '%s'      "$existing_json" | jq -r '.metadata.github_issue_synced_at   // ""')
      gh_synced_hash=$(printf '%s' "$existing_json" | jq -r '.metadata.github_issue_synced_hash // ""')

      local full_meta_json
      full_meta_json=$(printf '%s' "$base_meta_json" | jq -c \
        --arg ghu  "$gh_url" \
        --arg ghs  "$gh_synced" \
        --arg ghsh "$gh_synced_hash" \
        '. +
        (if $ghu  != "" then {github_issue_url:         $ghu}  else {} end) +
        (if $ghs  != "" then {github_issue_synced_at:   $ghs}  else {} end) +
        (if $ghsh != "" then {github_issue_synced_hash: $ghsh} else {} end)')

      # github_issue_number is a number — inject separately to keep type correct
      if [[ -n "$gh_num" && "$gh_num" != "null" ]]; then
        full_meta_json=$(printf '%s' "$full_meta_json" \
          | jq -c --argjson n "$gh_num" '. + {github_issue_number: $n}')
      fi

      bd update "$bd_id" --metadata "$full_meta_json" -q 2>/dev/null \
        || log_warn "Could not update metadata on $bd_id"

      log_info "  Updated: $bd_id"
      (( updated++ ))
    fi

  done < <(jq -c '.tasks[]' "$speckit_file")

  printf '\n'
  log_info "speckit-to-beads complete — created: $created, updated: $updated, skipped: $skipped, failed: $failed"
  [[ "$DRY_RUN" == true ]] && log_warn "Dry-run — no beads were created or updated."

  # Keep .beads/issues.jsonl current so it can be committed to git
  [[ $(( created + updated )) -gt 0 ]] && bd_export_jsonl

  [[ $failed -eq 0 ]] || return 1
}

# =============================================================================
# GITHUB BODY FORMATTER
# =============================================================================

# Produces a clean GitHub Markdown issue body.
# The hidden HTML comment <!-- beadsync:external_id:... --> is the idempotency
# anchor used by find_gh_issue_by_external_id().
# Expects the internal bead format produced by bd_json_to_internal().
format_gh_body() {
  local bead_json="$1"

  local title description acc_criteria notes spec_id external_id
  local due_at assignee estimated_minutes issue_type priority milestone
  title=$(printf '%s'             "$bead_json" | jq -r '.title                // ""')
  description=$(printf '%s'       "$bead_json" | jq -r '.description          // ""')
  acc_criteria=$(printf '%s'      "$bead_json" | jq -r '.acceptance_criteria  // ""')
  notes=$(printf '%s'             "$bead_json" | jq -r '.notes                // ""')
  spec_id=$(printf '%s'           "$bead_json" | jq -r '.spec_id              // ""')
  external_id=$(printf '%s'       "$bead_json" | jq -r '.external_id          // ""')
  due_at=$(printf '%s'            "$bead_json" | jq -r '.due_at               // ""')
  assignee=$(printf '%s'          "$bead_json" | jq -r '.assignee             // ""')
  estimated_minutes=$(printf '%s' "$bead_json" | jq -r '.estimated_minutes    // 0')
  issue_type=$(printf '%s'        "$bead_json" | jq -r '.issue_type           // "task"')
  priority=$(printf '%s'          "$bead_json" | jq -r '.priority             // 2')
  milestone=$(printf '%s'         "$bead_json" | jq -r '.metadata.milestone   // ""')

  local body=""

  [[ -n "$description" ]]  && body+="## Description\n\n${description}\n\n"
  [[ -n "$acc_criteria" ]] && body+="## Acceptance Criteria\n\n${acc_criteria}\n\n"
  [[ -n "$notes" ]]        && body+="## Notes\n\n${notes}\n\n"

  # Metadata table
  body+="---\n\n"
  body+="| Field | Value |\n"
  body+="| --- | --- |\n"
  body+="| Speckit ID | \`${spec_id}\` |\n"
  body+="| Issue type | \`${issue_type}\` |\n"
  body+="| Priority | P${priority} |\n"
  [[ -n "$due_at"    ]] && body+="| Due date | \`${due_at}\` |\n"
  [[ -n "$milestone" ]] && body+="| Milestone | ${milestone} |\n"
  [[ -n "$assignee"  ]] && body+="| Assignee | @${assignee} |\n"

  if [[ "$estimated_minutes" -gt 0 ]]; then
    local h=$(( estimated_minutes / 60 ))
    local m=$(( estimated_minutes % 60 ))
    local est=""
    [[ $h -gt 0 ]] && est+="${h}h"
    [[ $m -gt 0 ]] && est+=" ${m}m"
    body+="| Estimate | \`${est}\` |\n"
  fi

  body+="\n_Managed by [beadsync](https://github.com/steveyegge/beads). "
  body+="Edit the Bead, not this issue._\n\n"
  # Idempotency anchor — DO NOT REMOVE
  body+="<!-- beadsync:external_id:${external_id} -->"

  printf '%b' "$body"
}

# =============================================================================
# GITHUB HELPERS
# =============================================================================

# Search GitHub for an issue whose body contains the idempotency anchor.
# Returns the issue number, or empty string if not found.
find_gh_issue_by_external_id() {
  local repo="$1"
  local external_id="$2"

  log_debug "Searching GitHub for external_id: $external_id"

  local query="repo:${repo} in:body beadsync:external_id:${external_id}"
  gh api "search/issues" \
    --method GET \
    -f q="$query" \
    --jq '.items[0].number // empty' 2>/dev/null || true
}

# Ensure a label exists in the repo, creating it with a random colour if not.
ensure_label_exists() {
  local repo="$1"
  local label="$2"
  [[ -z "$label" ]] && return 0

  if ! gh api "repos/${repo}/labels" --jq ".[].name" 2>/dev/null \
        | grep -qxF "$label"; then
    log_debug "Creating label: $label"
    local colour
    colour=$(printf '%06X' $(( RANDOM % 16777215 )))
    gh api "repos/${repo}/labels" \
      --method POST \
      -f name="$label" \
      -f color="$colour" \
      --silent &>/dev/null || log_warn "Could not create label: $label"
  fi
}

# Resolve a milestone title to its numeric ID (or empty string).
get_milestone_id() {
  local repo="$1"
  local title="$2"
  [[ -z "$title" ]] && return 0
  gh api "repos/${repo}/milestones" \
    --jq ".[] | select(.title == \"${title}\") | .number" \
    2>/dev/null | head -1 || true
}

# Build a JSON array of labels from a newline-separated list.
labels_to_json_array() {
  local labels_raw="$1"
  printf '%s' "$labels_raw" | jq -Rc '[inputs | select(length > 0)]'
}

# =============================================================================
# BEADS → GITHUB  (Phase 2)
# =============================================================================

# ---------------------------------------------------------------------------
# Field mapping contract — Bead → GitHub Issue
#
# Bead field               GitHub field        Notes
# ─────────────────────────────────────────────────────────────────────────
# title                  → title              direct
# description            → body (section)     composed markdown
# acceptance_criteria    → body (section)     composed markdown
# notes                  → body (section)     composed markdown
# spec_id (metadata)     → body (table row)   reference only
# external_ref           → body (HTML comment) idempotency anchor
# labels[]               → labels[]           created if missing
# assignee               → assignees[0]       single assignee
# metadata.milestone     → milestone.title    resolved to milestone number
# status == "closed"     → state = "closed"   open otherwise
# metadata.github_issue_number ← stored back via bd update --metadata
# metadata.github_issue_url    ← stored back via bd update --metadata
# metadata.github_issue_synced_at   ← timestamp of last successful sync
# metadata.github_issue_synced_hash ← content_hash at last sync
# ---------------------------------------------------------------------------

# Global used by _sync_one_bead to avoid stdout pollution in subshells.
_BEAD_SYNC_RESULT=""

_sync_one_bead() {
  local repo="$1"
  local bd_raw_json="$2"   # raw JSON from bd show --json (single object)
  local bd_id="$3"
  local force_update="$4"
  # Sets _BEAD_SYNC_RESULT to: "created" | "updated" | "skipped" | "failed"

  _BEAD_SYNC_RESULT="failed"

  # Adapt bd JSON to the internal format that format_gh_body expects
  local bead_json
  bead_json=$(bd_json_to_internal "$bd_raw_json")

  local external_id title
  external_id=$(printf '%s' "$bead_json" | jq -r '.external_id // ""')
  title=$(printf '%s'       "$bead_json" | jq -r '.title       // ""')

  if [[ -z "$external_id" || -z "$title" ]]; then
    log_warn "Bead $bd_id missing external_ref or title — skipped"
    return
  fi

  log_debug "Syncing bead: $bd_id  ($external_id)"

  # ---- Resolve existing GitHub issue number (skipped in dry-run) -----------
  local gh_number=""
  local stored_number
  stored_number=$(printf '%s' "$bd_raw_json" | jq -r '.metadata.github_issue_number // empty')

  if [[ -n "$stored_number" && "$stored_number" != "null" ]]; then
    gh_number="$stored_number"
    log_debug "  Stored issue number: #$gh_number"
  elif [[ "$DRY_RUN" != true ]]; then
    gh_number=$(find_gh_issue_by_external_id "$repo" "$external_id")
    [[ -n "$gh_number" ]] && log_debug "  Found via search: #$gh_number"
  fi

  # ---- Prepare GitHub payload ----------------------------------------------
  local body
  body=$(format_gh_body "$bead_json")

  local labels_raw
  labels_raw=$(printf '%s' "$bead_json" | jq -r '.labels // [] | .[]' 2>/dev/null)

  local assignee
  assignee=$(printf '%s' "$bead_json" | jq -r '.assignee // ""')

  local bead_status gh_state
  bead_status=$(printf '%s' "$bead_json" | jq -r '.status // "open"')
  [[ "$bead_status" == "closed" ]] && gh_state="closed" || gh_state="open"

  # ---- Ensure labels exist (skip in dry-run) -------------------------------
  if [[ "$DRY_RUN" != true ]]; then
    while IFS= read -r lbl; do
      [[ -n "$lbl" ]] && ensure_label_exists "$repo" "$lbl"
    done <<< "$labels_raw"
  fi

  # ---- Milestone (skip in dry-run) -----------------------------------------
  local milestone_title milestone_id=""
  milestone_title=$(printf '%s' "$bead_json" | jq -r '.metadata.milestone // ""')
  if [[ -n "$milestone_title" && "$DRY_RUN" != true ]]; then
    milestone_id=$(get_milestone_id "$repo" "$milestone_title")
  fi

  local now
  now=$(iso8601_now)
  local current_hash
  current_hash=$(printf '%s' "$bd_raw_json" | jq -r '.metadata.content_hash // ""')

  # ---- CREATE new issue ----------------------------------------------------
  if [[ -z "$gh_number" ]]; then
    log_info "  Creating issue: $title"

    if [[ "$DRY_RUN" == true ]]; then
      local dry_labels
      dry_labels=$(printf '%s' "$labels_raw" | tr '\n' ' ')
      log_dry "  Would create: $title  [labels: ${dry_labels:-none}]"
      _BEAD_SYNC_RESULT="created"; return
    fi

    local create_args=(--repo "$repo" --title "$title" --body "$body")
    while IFS= read -r lbl; do
      [[ -n "$lbl" ]] && create_args+=(--label "$lbl")
    done <<< "$labels_raw"
    [[ -n "$assignee" ]] && create_args+=(--assignee "$assignee")

    local gh_response
    if ! gh_response=$(gh issue create "${create_args[@]}" 2>&1); then
      log_error "  Failed to create issue '$title': $gh_response"
      return
    fi

    local gh_url gh_num_new
    gh_url=$(printf '%s' "$gh_response" | grep -Eo 'https://github\.com/[^ ]+' | head -1)
    gh_num_new=$(printf '%s' "$gh_url" | grep -Eo '[0-9]+$')

    # Close immediately if bead status is closed
    [[ "$gh_state" == "closed" && -n "$gh_num_new" ]] && \
      gh issue close "$gh_num_new" --repo "$repo" &>/dev/null || true

    log_info "  Created: $gh_url"

    # Write back GitHub metadata into the bead via bd update --metadata
    local new_meta
    new_meta=$(printf '%s' "$bd_raw_json" | jq -c \
      --argjson num  "$gh_num_new" \
      --arg     url  "$gh_url" \
      --arg     sync "$now" \
      --arg     hash "$current_hash" \
      '(.metadata // {}) + {
        github_issue_number:      $num,
        github_issue_url:         $url,
        github_issue_synced_at:   $sync,
        github_issue_synced_hash: $hash
      }')
    bd update "$bd_id" --metadata "$new_meta" -q 2>/dev/null \
      || log_warn "  Could not write back GitHub metadata to bead $bd_id"

    _BEAD_SYNC_RESULT="created"; return
  fi

  # ---- UPDATE existing issue -----------------------------------------------
  local synced_hash
  synced_hash=$(printf '%s' "$bd_raw_json" | jq -r '.metadata.github_issue_synced_hash // ""')

  if [[ "$current_hash" == "$synced_hash" && "$force_update" != true ]]; then
    log_debug "  Issue #$gh_number unchanged — skipped"
    _BEAD_SYNC_RESULT="skipped"; return
  fi

  log_info "  Updating issue #$gh_number: $title"

  if [[ "$DRY_RUN" == true ]]; then
    log_dry "  Would update #$gh_number: $title"
    _BEAD_SYNC_RESULT="updated"; return
  fi

  # Use REST API for updates (gh issue edit --add-label doesn't replace labels)
  local labels_json_arr
  labels_json_arr=$(labels_to_json_array "$labels_raw")

  local patch_data=()
  patch_data+=(-f  title="$title")
  patch_data+=(-f  body="$body")
  patch_data+=(-f  state="$gh_state")
  [[ -n "$milestone_id" ]] && patch_data+=(-F milestone="$milestone_id")

  if ! gh api "repos/${repo}/issues/${gh_number}" \
        --method PATCH "${patch_data[@]}" --silent; then
    log_error "  Failed to update issue #$gh_number"
    return
  fi

  # Replace labels atomically via the labels endpoint
  if printf '%s' "$labels_json_arr" | jq -e 'length > 0' &>/dev/null; then
    gh api "repos/${repo}/issues/${gh_number}/labels" \
      --method PUT \
      --input <(printf '%s' "$labels_json_arr" | jq '{labels: .}') \
      --silent &>/dev/null || log_warn "  Could not update labels on #$gh_number"
  fi

  # Set assignee
  if [[ -n "$assignee" ]]; then
    gh api "repos/${repo}/issues/${gh_number}/assignees" \
      --method POST \
      -F "assignees[]=$assignee" \
      --silent &>/dev/null || log_warn "  Could not set assignee on #$gh_number"
  fi

  log_info "  Updated: https://github.com/${repo}/issues/${gh_number}"

  # Write back updated sync metadata into the bead via bd update --metadata
  local new_meta
  new_meta=$(printf '%s' "$bd_raw_json" | jq -c \
    --arg sync "$now" \
    --arg hash "$current_hash" \
    '(.metadata // {}) + {
      github_issue_synced_at:   $sync,
      github_issue_synced_hash: $hash
    }')
  bd update "$bd_id" --metadata "$new_meta" -q 2>/dev/null \
    || log_warn "  Could not write back sync metadata to bead $bd_id"

  _BEAD_SYNC_RESULT="updated"
}

_run_gh_sync() {
  local repo="$1"
  local force_update="$2"

  [[ "$repo" =~ ^[^/]+/[^/]+$ ]] || die "Invalid --repo format (expected owner/name): $repo"

  [[ "$DRY_RUN" != true ]] && check_bd_dep
  [[ "$DRY_RUN" != true ]] && check_bd_init
  [[ "$DRY_RUN" != true ]] && check_bd_stale
  [[ "$DRY_RUN" != true ]] && check_gh_dep

  log_info "Repository : $repo"
  [[ "$DRY_RUN"      == true ]] && log_warn "Dry-run mode — no changes will be made"
  [[ "$force_update" == true ]] && log_warn "Force mode  — all issues will be updated"

  # Fetch all beads tagged with 'speckit' from the bd database
  local beads_list
  beads_list=$(bd list --all --limit 0 -l speckit --json 2>/dev/null || true)

  if [[ -z "$beads_list" || "$beads_list" == "[]" || "$beads_list" == "null" ]]; then
    log_warn "No beads with label 'speckit' found.  Run: beadsync speckit-to-beads first."
    return 0
  fi

  local created=0 updated=0 skipped=0 failed=0 bead_count=0

  while IFS= read -r bead_item; do
    local bd_id
    bd_id=$(printf '%s' "$bead_item" | jq -r '.id // empty')
    [[ -z "$bd_id" ]] && continue

    # Fetch full bead details — list output may omit description/notes/metadata
    local full_bead_json
    if ! full_bead_json=$(bd_get_bead_json "$bd_id") || [[ -z "$full_bead_json" ]]; then
      log_warn "Could not fetch bead details for: $bd_id"
      (( failed++ )); continue
    fi

    (( bead_count++ ))

    _BEAD_SYNC_RESULT="failed"
    _sync_one_bead "$repo" "$full_bead_json" "$bd_id" "$force_update" || true

    case "$_BEAD_SYNC_RESULT" in
      created) (( created++ )) ;;
      updated) (( updated++ )) ;;
      skipped) (( skipped++ )) ;;
      *)       (( failed++  )) ;;
    esac
  done < <(printf '%s' "$beads_list" | jq -c '.[]' 2>/dev/null)

  if [[ $bead_count -eq 0 ]]; then
    log_warn "No beads found to sync."
    return 0
  fi

  printf '\n'
  log_info "Sync complete — created: $created, updated: $updated, skipped: $skipped, failed: $failed"

  # Keep .beads/issues.jsonl current (captures github_issue_* metadata write-backs)
  [[ $(( created + updated )) -gt 0 ]] && bd_export_jsonl

  [[ $failed -eq 0 ]] || { log_error "$failed bead(s) failed to sync"; return 1; }
}

cmd_beads_to_gh() {
  local repo=""
  local force_update=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo|-r)    repo="$2";        shift 2 ;;
      --force)      force_update=true; shift ;;
      --dry-run)    DRY_RUN=true;      shift ;;
      --verbose|-v) VERBOSE=true;      shift ;;
      -*)           die "Unknown option: $1" ;;
      *)            die "Unexpected argument '$1'.  Note: a beads directory is no longer required — beads are read directly from bd." ;;
    esac
  done

  [[ -n "$repo" ]] || die_usage "Usage: beadsync beads-to-gh --repo owner/name"

  _run_gh_sync "$repo" "$force_update"
}

cmd_sync() {
  local repo=""
  local force_update=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo|-r)    repo="$2";        shift 2 ;;
      --force)      force_update=true; shift ;;
      --dry-run)    DRY_RUN=true;      shift ;;
      --verbose|-v) VERBOSE=true;      shift ;;
      -*)           die "Unknown option: $1" ;;
      *)            die "Unexpected argument '$1'.  Note: a beads directory is no longer required — beads are read directly from bd." ;;
    esac
  done

  [[ -n "$repo" ]] || die_usage "Usage: beadsync sync --repo owner/name"

  _run_gh_sync "$repo" "$force_update"
}

# =============================================================================
# STATUS REPORT
# =============================================================================

cmd_status() {
  check_bd_dep
  check_bd_init

  local beads_list
  beads_list=$(bd list --all --limit 0 -l speckit --json 2>/dev/null || true)

  if [[ -z "$beads_list" || "$beads_list" == "[]" || "$beads_list" == "null" ]]; then
    if [[ -f ".beads/issues.jsonl" ]]; then
      log_warn "bd database is empty but .beads/issues.jsonl exists."
      log_warn "Run: bd import -i .beads/issues.jsonl  then try again."
    else
      log_warn "No beads with label 'speckit' found.  Run: beadsync speckit-to-beads first."
    fi
    return 0
  fi

  local total=0 synced=0 pending=0

  printf '%-20s %-48s %-14s %-12s %s\n' "Bead ID" "Title" "Status" "GH Issue" "Synced?"
  printf '%s\n' "$(printf '%0.s─' {1..110})"

  while IFS= read -r bead_item; do
    local bd_id
    bd_id=$(printf '%s' "$bead_item" | jq -r '.id // empty')
    [[ -z "$bd_id" ]] && continue

    local full_json
    full_json=$(bd_get_bead_json "$bd_id") || continue
    [[ -z "$full_json" ]] && continue

    local title status gh_num synced_hash content_hash
    title=$(printf '%s'        "$full_json" | jq -r '.title                              // "(untitled)"')
    status=$(printf '%s'       "$full_json" | jq -r '.status                             // "?"')
    gh_num=$(printf '%s'       "$full_json" | jq -r '.metadata.github_issue_number       // "-"')
    synced_hash=$(printf '%s'  "$full_json" | jq -r '.metadata.github_issue_synced_hash  // ""')
    content_hash=$(printf '%s' "$full_json" | jq -r '.metadata.content_hash              // ""')

    local sync_state
    if [[ "$gh_num" == "-" || "$gh_num" == "null" ]]; then
      sync_state="not synced"
      (( pending++ ))
    elif [[ "$synced_hash" != "$content_hash" ]]; then
      sync_state="needs update"
      (( pending++ ))
    else
      sync_state="up to date"
      (( synced++ ))
    fi

    (( total++ ))
    printf '%-20s %-48s %-14s %-12s %s\n' \
      "$bd_id" \
      "$(printf '%s' "$title" | cut -c1-47)" \
      "$status" \
      "#$gh_num" \
      "$sync_state"
  done < <(printf '%s' "$beads_list" | jq -c '.[]' 2>/dev/null)

  printf '\n'
  log_info "Total: $total | Synced: $synced | Needs sync: $pending"
}

# =============================================================================
# USAGE
# =============================================================================

show_usage() {
  cat <<EOF
${BOLD}beadsync${RESET} v${VERSION}  —  Speckit → Beads → GitHub Issues

${BOLD}USAGE${RESET}
  beadsync <command> [options]

${BOLD}COMMANDS${RESET}

  ${CYAN}speckit-to-beads${RESET}  <speckit.json>  [--project ID]
    Convert a Speckit JSON export into Beads using bd.
    Each task is created or updated as a real Bead in the local bd database,
    tagged with the 'speckit' label for downstream filtering.
    Idempotent: re-running updates only changed tasks.

      --project, -p ID Project identifier used to namespace Bead external refs.
                       Auto-read from export's project.id field; falls
                       back to the filename stem if absent.
      --dry-run        Preview without calling bd
      --verbose, -v    Verbose output

  ${CYAN}beads-to-gh${RESET}  --repo owner/name
    Push Beads (label=speckit) to GitHub Issues.  Creates new issues and updates
    existing ones.  Manual GitHub edits are preserved unless --force.

      --repo, -r REPO  GitHub repo, e.g. acme/my-project  (required)
      --force          Override GitHub edits; always push Bead content
      --dry-run        Preview without touching GitHub
      --verbose, -v    Verbose output

  ${CYAN}sync${RESET}  --repo owner/name
    Alias for beads-to-gh.  Only pushes Beads whose content has changed.

      Same options as beads-to-gh.

  ${CYAN}status${RESET}
    Print a table of all Beads (label=speckit) and their GitHub sync state.

${BOLD}ENVIRONMENT VARIABLES${RESET}

  GITHUB_TOKEN    Optional — gh CLI manages auth by default (gh auth login)

${BOLD}DEPENDENCIES${RESET}

  Required: bash ≥ 4.3, jq, gh (GitHub CLI), bd (Beads CLI)
  macOS:    shasum (built-in)  or  sha256sum

  Install: brew install jq gh
           npm i -g @beads/bd   (or: brew install beads)

${BOLD}TEAM WORKFLOW (multi-machine)${RESET}

  beadsync auto-exports .beads/issues.jsonl after every write command so the
  bead database can be committed to git and shared with your team.

  Setup — add to your project's .gitignore:
    .beads/dolt/          ← binary Dolt DB, never commit
    .beads/*.db

  Commit the JSONL (one bead per line, git-mergeable):
    git add .beads/issues.jsonl && git commit -m "Update beads"

  Workflow for each team member:
    git pull
    bd import -i .beads/issues.jsonl   ← rebuild local Dolt DB
    beadsync speckit-to-beads ...      ← creates/updates beads + auto-exports
    beadsync sync --repo ...           ← pushes to GitHub   + auto-exports
    git add .beads/issues.jsonl && git commit && git push

${BOLD}EXIT CODES${RESET}

  0   Success
  1   Runtime error (e.g. a bead failed to sync)
  2   Usage / argument error

${BOLD}EXAMPLES${RESET}

  # Phase 1 — convert Speckit tasks to Beads in bd
  ./beadsync speckit-to-beads speckit_export.json
  ./beadsync speckit-to-beads speckit_export.json --dry-run
  ./beadsync speckit-to-beads speckit_export.json --project myproject

  # Phase 2a — push all Beads to GitHub Issues (first time)
  ./beadsync beads-to-gh --repo acme/my-project --dry-run
  ./beadsync beads-to-gh --repo acme/my-project

  # Phase 2b — sync changed Beads (idempotent, run as often as needed)
  ./beadsync sync --repo acme/my-project

  # Force-push all Beads (overrides any manual GitHub edits)
  ./beadsync sync --repo acme/my-project --force

  # Check sync state without touching anything
  ./beadsync status

${BOLD}SOURCE OF TRUTH MODEL${RESET}

  1. Speckit is canonical until Beads are created in bd.
  2. After Beads exist in bd, Beads are the source of truth.
  3. GitHub Issues are read-only projections of Beads.
  4. GitHub edits do NOT override Beads (unless --force is used).
  5. Changes flow:
       Phase 1:  Speckit → beadsync speckit-to-beads → bd (Bead database)
       Phase 2:  bd Beads → beadsync sync → GitHub Issues

EOF
}

# =============================================================================
# MAIN
# =============================================================================

main() {
  check_core_deps

  [[ $# -gt 0 ]] || { show_usage; exit 0; }

  local cmd="$1"; shift

  case "$cmd" in
    speckit-to-beads|s2b)   cmd_speckit_to_beads "$@" ;;
    beads-to-gh|b2g)        cmd_beads_to_gh "$@" ;;
    sync)                   cmd_sync "$@" ;;
    status|st)              cmd_status "$@" ;;
    version|--version|-V)   printf 'beadsync v%s\n' "$VERSION"; exit 0 ;;
    help|--help|-h)         show_usage; exit 0 ;;
    *)
      log_error "Unknown command: $cmd"
      show_usage
      exit 2
      ;;
  esac
}

main "$@"
